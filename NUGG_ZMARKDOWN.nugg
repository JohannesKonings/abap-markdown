<?xml version="1.0" encoding="utf-8"?>
<nugget name="ZMARKDOWN">
 <CLAS CLSNAME="ZMARKDOWN" VERSION="1" LANGU="P" DESCRIPT="ABAP Markdown" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT_ATTRIBUTE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="30 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element_attribute,
      name type string,
      value type string,
    end of ty_element_attribute
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT_ATTRIBUTE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="83 " TYPESRC_LENG="0 " TYPESRC="ty_t_element_attribute type standard table of ty_element_attribute with key name
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT0" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element0,
      name type string,
      handler type string,
      attributes type ty_t_element_attribute,
      text type string,
      lines type standard table of string with default key,
    end of ty_element0
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT0" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="68 " TYPESRC_LENG="0 " TYPESRC="ty_t_element0 type standard table of ty_element0 with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT1" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="30 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element1,
      name type string,
      handler type string,
      attributes type ty_t_element_attribute,
      text type string,
      texts type ty_t_element0,
      lines type standard table of string with default key,
    end of ty_element1
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT1" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="32 " SRCCOLUMN1="4 " SRCROW2="32 " SRCCOLUMN2="68 " TYPESRC_LENG="0 " TYPESRC="ty_t_element1 type standard table of ty_element1 with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT2" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="34 " SRCCOLUMN1="4 " SRCROW2="41 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element2,
      name type string,
      handler type string,
      attributes type ty_t_element_attribute,
      text type string,
      texts type ty_t_element1,
      lines type standard table of string with default key,
    end of ty_element2
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT2" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="8 " TYPTYPE="4" SRCROW1="43 " SRCCOLUMN1="4 " SRCROW2="43 " SRCCOLUMN2="68 " TYPESRC_LENG="0 " TYPESRC="ty_t_element2 type standard table of ty_element2 with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT3" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="9 " TYPTYPE="4" SRCROW1="45 " SRCCOLUMN1="4 " SRCROW2="52 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element3,
      name type string,
      handler type string,
      attributes type ty_t_element_attribute,
      text type string,
      texts type ty_t_element2,
      lines type standard table of string with default key,
    end of ty_element3
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT3" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="10 " TYPTYPE="4" SRCROW1="54 " SRCCOLUMN1="4 " SRCROW2="54 " SRCCOLUMN2="68 " TYPESRC_LENG="0 " TYPESRC="ty_t_element3 type standard table of ty_element3 with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT4" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="11 " TYPTYPE="4" SRCROW1="56 " SRCCOLUMN1="4 " SRCROW2="63 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element4,
      name type string,
      handler type string,
      attributes type ty_t_element_attribute,
      text type string,
      texts type ty_t_element3,
      lines type standard table of string with default key,
    end of ty_element4
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT4" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="12 " TYPTYPE="4" SRCROW1="65 " SRCCOLUMN1="4 " SRCROW2="65 " SRCCOLUMN2="68 " TYPESRC_LENG="0 " TYPESRC="ty_t_element4 type standard table of ty_element4 with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT5" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="13 " TYPTYPE="4" SRCROW1="67 " SRCCOLUMN1="4 " SRCROW2="74 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of ty_element5,
      name type string,
      handler type string,
      attributes type ty_t_element_attribute,
      text type ty_element4,
      texts type ty_t_element4,
      lines type standard table of string with default key,
    end of ty_element5
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT5" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="14 " TYPTYPE="4" SRCROW1="76 " SRCCOLUMN1="4 " SRCROW2="76 " SRCCOLUMN2="68 " TYPESRC_LENG="0 " TYPESRC="ty_t_element5 type standard table of ty_element5 with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_ELEMENT" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="15 " TYPTYPE="1" TYPE="TY_ELEMENT5" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_T_ELEMENT" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="16 " TYPTYPE="4" SRCROW1="79 " SRCCOLUMN1="4 " SRCROW2="79 " SRCCOLUMN2="66 " TYPESRC_LENG="0 " TYPESRC="ty_t_element type standard table of ty_element with default key
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_BLOCK" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="17 " TYPTYPE="4" SRCROW1="81 " SRCCOLUMN1="4 " SRCROW2="101 " SRCCOLUMN2="18 " TYPESRC_LENG="0 " TYPESRC='begin of ty_block,
      &quot;// general block fields
      continuable type flag,
      identified type flag,
      interrupted type flag,
      hidden type flag,
      closed type flag,
      type type string,
      markup type string,
      element type ty_element,
      &quot;// specific block fields
      char type c length 1,
      complete type flag,
      indent type i,
      pattern type string,
      li type ty_element4,
      name type string,
      depth type i,
      void type flag,
      alignments type standard table of string with default key,
    end of ty_block
'/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_LINE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="18 " TYPTYPE="4" SRCROW1="103 " SRCCOLUMN1="4 " SRCROW2="107 " SRCCOLUMN2="17 " TYPESRC_LENG="0 " TYPESRC="begin of ty_line,
      body type string,
      indent type i,
      text type string,
    end of ty_line
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_EXCERPT" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="19 " TYPTYPE="4" SRCROW1="109 " SRCCOLUMN1="4 " SRCROW2="112 " SRCCOLUMN2="20 " TYPESRC_LENG="0 " TYPESRC="begin of ty_excerpt,
      text type string,
      context type string,
    end of ty_excerpt
"/>
  <types CLSNAME="ZMARKDOWN" CMPNAME="TY_INLINE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="20 " TYPTYPE="4" SRCROW1="114 " SRCCOLUMN1="4 " SRCROW2="119 " SRCCOLUMN2="19 " TYPESRC_LENG="0 " TYPESRC="begin of ty_inline,
      position type i,
      markup type string,
      extent type string,
      element type ty_element,
    end of ty_inline
"/>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes


*!
class lcl_string implementation.
  method lif_value_type~copy.
    &quot;! Copies the value of the source object to itself
    data: lo_string type ref to lcl_string.
    lo_string ?= source.
    me-&gt;data = lo_string-&gt;data.
  endmethod.                    &quot;lif_value_type~copy
endclass.                    &quot;lcl_string IMPLEMENTATION


*!
class lcl_string_array implementation.
  method append.
    &quot;! Append a value to the end of the array
    append value to me-&gt;data.
  endmethod.                    &quot;append

  method append_array.
    &quot;! Append the items of an array to this array
    field-symbols: &lt;item&gt; type string.
    loop at array-&gt;data assigning &lt;item&gt;.
      append( &lt;item&gt; ).
    endloop.
  endmethod.                    &quot;append_array

  method delete.
    &quot;! Deletes a value from the array
    delete me-&gt;data where table_line = value.
  endmethod.                    &quot;delete

  method find.
    &quot;! Returns the index of the first occurrence of a value in the array,
    &quot;!  or 0 if not found.
    read table me-&gt;data with key table_line = value
      transporting no fields.
    if sy-subrc = 0.
      index = sy-tabix.
    endif.
  endmethod.                    &quot;find

  method lif_value_type~copy.
    &quot;! Copies the value of the source object to itself
    data: lo_sa type ref to lcl_string_array.
    lo_sa ?= source.
    me-&gt;data = lo_sa-&gt;data.
  endmethod.                    &quot;lif_value_type~copy
endclass.                    &quot;lcl_array IMPLEMENTATION


*!
class lcl_hashmap implementation.
  method constructor.
    &quot;! Hashmap constructor
    &quot;!
    &quot;! @parameter value_type The value part class name. This must be a valid
    &quot;!                       ABAP class name, or a composition of valid ABAP
    &quot;!                       class names separated by a colon.
    if value_type cs &apos;:&apos;.
      find regex &apos;^([^\s:]+)(?::(.+))?$&apos; in value_type
        submatches me-&gt;value_type me-&gt;subsequent_hashmap_value_type.
      if sy-subrc &lt;&gt; 0.
        me-&gt;value_type = value_type.
      endif.
    else.
      me-&gt;value_type = value_type.
    endif.
    translate: me-&gt;value_type to upper case,
               me-&gt;subsequent_hashmap_value_type to upper case.
  endmethod.                    &quot;constructor

  method new.
    &quot;! Adds a new item to the hashmap
    &quot;! The value part in the new item will be created dynamically with
    &quot;! the type passed to the constructor (sorta like a template based hashmap).
    &quot;!
    &quot;! @return The instance of the created item&apos;s value part, or empty if the item already exists.
    data: ls_new_item type ty_item.
    field-symbols: &lt;item&gt; type ty_item.
    ls_new_item-key = key.
    insert ls_new_item into table me-&gt;data assigning &lt;item&gt;.
    check sy-subrc = 0.

    if me-&gt;value_type = &apos;LCL_HASHMAP&apos; and me-&gt;subsequent_hashmap_value_type is not initial.
      create object &lt;item&gt;-value type lcl_hashmap
        exporting value_type = me-&gt;subsequent_hashmap_value_type.
    else.
      create object &lt;item&gt;-value type (me-&gt;value_type).
    endif.
    value = &lt;item&gt;-value.
  endmethod.                    &quot;new

  method exists.
    &quot;! Checks if a item exists in the hashmap.
    &quot;! @return A flag indicating if the item exists.
    read table me-&gt;data with key key = key
      transporting no fields.
    if sy-subrc = 0.
      exists = &apos;X&apos;.
    endif.
  endmethod.                    &quot;exists

  method get.
    &quot;! Gets an item reference from the hashmap.
    &quot;! If the item is not found, a new item is created, as if using the method new.
    &quot;! @return The reference to the value part of the item.
    field-symbols: &lt;item&gt; type ty_item.
    read table me-&gt;data assigning &lt;item&gt;
      with key key = key.
    if sy-subrc = 0.
      value = &lt;item&gt;-value.
    else.
      value = new( key ).
    endif.
  endmethod.                    &quot;get

  method set.
    &quot;! Sets the value of an item in the hashmap.
    &quot;! If the item does not yet exist, an item is created with the passed key/value pair.
    &quot;! If the item already exists, its value is replaced with the passed value.
    data: lo_item type ref to lif_value_type.
    lo_item = get( key ).
    lo_item-&gt;copy( value ).
  endmethod.                    &quot;set

  method delete.
    &quot;! Deletes an item from the hashmap.
    delete me-&gt;data where key = key.
  endmethod.                    &quot;delete

  method lif_value_type~copy.
    &quot;! Copies the contents of another hashmap to this hashmap
    &quot;!
    &quot;! @parameter hashmap The other (source) hashmap
    data: lo_hashmap type ref to lcl_hashmap,
          lo_value type ref to lif_value_type.
    field-symbols: &lt;item&gt; type ty_item.
    lo_hashmap ?= source.
    loop at lo_hashmap-&gt;data assigning &lt;item&gt;.
      lo_value = me-&gt;new( &lt;item&gt;-key ).
      lo_value-&gt;copy( &lt;item&gt;-value ).
    endloop.
  endmethod.                    &quot;lif_value_type~copy
endclass.                    &quot;lcl_hashmap IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature

&quot;!
&quot;! Value type interface
*!
interface lif_value_type.
  methods: copy importing source type ref to lif_value_type.
endinterface.                    &quot;lif_value_type

&quot;!
&quot;! String class for use in template objects
*!
class lcl_string definition final.
  public section.
    interfaces lif_value_type.
    data: data type string.
    aliases: copy for lif_value_type~copy.
endclass.                    &quot;lcl_string DEFINITION

&quot;!
&quot;! String array class for use in template objects
*!
class lcl_string_array definition final.
  public section.
    interfaces lif_value_type.
    data: data type table of string.

    methods:
      append importing value type clike,
      append_array importing array type ref to lcl_string_array,
      delete importing value type clike,
      find importing value type clike returning value(index) type i.

    aliases: copy for lif_value_type~copy.
endclass.                    &quot;lcl_array DEFINITION

&quot;!
&quot;! Hashmap template class
&quot;! The key type is `string`, and the value type must be an object.
&quot;!
&quot;! A compound value type may be used, separating the basic type and its subsequent
&quot;!  value type by a colon.
&quot;! Ex: &apos;lcl_hashmap:lcl_string_array&apos; =&gt; The value type will be lcl_hashmap,
&quot;!     and the value hashmaps&apos; values type will be of type lcl_string_array.
&quot;! Ex: &apos;lcl_hashmap:lcl_hashmap:lcl_hashmap:lcl_string&apos; =&gt; Recursive composition,
&quot;!     for use of a 4-dimensional hashmap.
*!
class lcl_hashmap definition final.
  public section.
    interfaces lif_value_type.
    types:
    begin of ty_item,
      key type string,
      value type ref to lif_value_type,
    end of ty_item,
    ty_hashmap type hashed table of ty_item with unique key key.

    data: data type ty_hashmap.

    methods:
      constructor importing value(value_type) type clike default &apos;lcl_string&apos;,
      new importing key type clike returning value(value) type ref to lif_value_type,
      exists importing key type clike returning value(exists) type flag,
      get importing key type clike returning value(value) type ref to lif_value_type,
      set importing key type clike value type ref to lif_value_type,
      delete importing key type string.

    aliases: copy for lif_value_type~copy.

  private section.
    data: value_type type string,
          subsequent_hashmap_value_type type string.
endclass.                    &quot;lcl_hashmap DEFINITION</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>class abap_unit_string_tests definition deferred.
class abap_unit_string_array_tests definition deferred.
class abap_unit_hashmap_tests definition deferred.
class abap_unit_zmarkdown_tests definition deferred.

class zmarkdown definition local friends
  abap_unit_string_tests
  abap_unit_string_array_tests
  abap_unit_hashmap_tests
  abap_unit_zmarkdown_tests.


&quot;!
&quot;! Unit test class for the string template class
*!
class abap_unit_string_tests definition for testing.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration   Short
  private section.
    data: o_string type ref to lcl_string.
    methods:
      copying for testing.
endclass.                    &quot;abap_unit_string_tests DEFINITION
*!
class abap_unit_string_tests implementation.
  method copying.
    create object o_string.
    o_string-&gt;data = &apos;SpongeBob&apos;.

    data: lo_new type ref to lcl_string.
    create object lo_new.
    lo_new-&gt;copy( o_string ).
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;SpongeBob&apos;
      act = lo_new-&gt;data
    ).
  endmethod.                    &quot;copying
endclass.                    &quot;abap_unit_string_tests IMPLEMENTATION


&quot;!
&quot;! Unit test class for the string array template class
*!
class abap_unit_string_array_tests definition for testing.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration   Short
  private section.
    data: o_sa type ref to lcl_string_array.
    methods:
      copying for testing,
      append for testing,
      append_array for testing,
      delete for testing,
      find for testing.
endclass.                    &quot;abap_unit_string_array_tests DEFINITION
*!
class abap_unit_string_array_tests implementation.
  method copying.
    create object o_sa.
    o_sa-&gt;append( &apos;One&apos; ).
    o_sa-&gt;append( &apos;Two&apos; ).
    o_sa-&gt;append( &apos;Three&apos; ).

    data: lo_new type ref to lcl_string_array,
          lv_conc type string.
    create object lo_new.
    lo_new-&gt;copy( o_sa ).

    concatenate lines of lo_new-&gt;data into lv_conc.
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;OneTwoThree&apos;
      act = lv_conc
    ).
  endmethod.                    &quot;copying

  method append.
    create object o_sa.
    o_sa-&gt;append( &apos;One&apos; ).
    o_sa-&gt;append( &apos;Two&apos; ).
    o_sa-&gt;append( &apos;Three&apos; ).

    data: lv_conc type string.
    concatenate lines of o_sa-&gt;data into lv_conc.
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;OneTwoThree&apos;
      act = lv_conc
    ).
  endmethod.                    &quot;append

  method append_array.
    create object o_sa.
    o_sa-&gt;append( &apos;One&apos; ).
    o_sa-&gt;append( &apos;Two&apos; ).
    o_sa-&gt;append( &apos;Three&apos; ).

    data: lo_new type ref to lcl_string_array,
          lv_conc type string.
    create object lo_new.
    lo_new-&gt;append_array( o_sa ).

    concatenate lines of lo_new-&gt;data into lv_conc.
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;OneTwoThree&apos;
      act = lv_conc
    ).
  endmethod.                    &quot;append_array

  method delete.
    create object o_sa.
    o_sa-&gt;append( &apos;One&apos; ).
    o_sa-&gt;append( &apos;Two&apos; ).
    o_sa-&gt;append( &apos;Three&apos; ).

    o_sa-&gt;delete( &apos;Two&apos; ).

    data: lv_conc type string.
    concatenate lines of o_sa-&gt;data into lv_conc.
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;OneThree&apos;
      act = lv_conc
    ).
  endmethod.                    &quot;delete

  method find.
    create object o_sa.
    o_sa-&gt;append( &apos;One&apos; ).
    o_sa-&gt;append( &apos;Two&apos; ).
    o_sa-&gt;append( &apos;Three&apos; ).

    data: lv_index type i.
    lv_index = o_sa-&gt;find( &apos;Two&apos; ).
    cl_aunit_assert=&gt;assert_equals(
      exp = 2
      act = lv_index
    ).
  endmethod.                    &quot;find
endclass.                    &quot;abap_unit_string_array_tests IMPLEMENTATION

&quot;!
&quot;! Unit test class for the hashmap template class
*!
class abap_unit_hashmap_tests definition for testing.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration   Short
  private section.
    data: o_hm type ref to lcl_hashmap.
    methods:
      copying for testing,
      create_string_hashmap for testing,
      create_array_hashmap for testing,
      create_hashmap_hashmap for testing,
      create_4_dimension_hashmap for testing,
      new for testing,
      get for testing,
      set for testing,
      exists for testing,
      delete for testing.
endclass.                    &quot;abap_unit_hashmap_tests DEFINITION
*!
class abap_unit_hashmap_tests implementation.
  method copying.
    create object o_hm
      exporting
        value_type = &apos;lcl_string&apos;.
    data: lo_value type ref to lcl_string.
    lo_value ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
    lo_value-&gt;data = &apos;ValueOne&apos;.

    data: lo_new type ref to lcl_hashmap.
    create object lo_new
      exporting
        value_type = &apos;lcl_string&apos;.
    lo_new-&gt;copy( o_hm ).
    lo_value ?= lo_new-&gt;get( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;ValueOne&apos;
      act = lo_value-&gt;data
    ).
  endmethod.                    &quot;copying

  method create_string_hashmap.
    data: lo_string type ref to lcl_string.
    create object o_hm. &quot;// default
    lo_string ?= o_hm-&gt;new( &apos;IdxOne&apos; ).

    create object o_hm
      exporting
        value_type = &apos;lcl_string&apos;.
    lo_string ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
  endmethod.                    &quot;create_string_hashmap

  method create_array_hashmap.
    data: lo_array type ref to lcl_string_array.
    create object o_hm
      exporting
        value_type = &apos;lcl_string_array&apos;.
    lo_array ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
  endmethod.                    &quot;create_array_hashmap

  method create_hashmap_hashmap.
    data: lo_hashmap type ref to lcl_hashmap.
    create object o_hm
      exporting
        value_type = &apos;lcl_hashmap&apos;.
    lo_hashmap ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
  endmethod.                    &quot;create_hashmap_hashmap

  method create_4_dimension_hashmap.
    data: lo_hashmap1 type ref to lcl_hashmap,
          lo_hashmap2 type ref to lcl_hashmap,
          lo_hashmap3 type ref to lcl_hashmap.
    create object o_hm
      exporting
        value_type = &apos;lcl_hashmap:lcl_hashmap:lcl_hashmap&apos;.
    lo_hashmap1 ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
    lo_hashmap2 ?= lo_hashmap1-&gt;new( &apos;IdxTwo&apos; ).
    lo_hashmap3 ?= lo_hashmap2-&gt;new( &apos;IdxThree&apos; ).
  endmethod.                    &quot;create_4_dimension_hashmap

  method new.
    data: lo_string type ref to lcl_string.
    create object o_hm.
    lo_string ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lo_string ).
    lo_string-&gt;data = &apos;ValueOne&apos;.

    lo_string ?= o_hm-&gt;new( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_initial( lo_string ).
  endmethod.                    &quot;new

  method get.
    data: lo_string type ref to lcl_string.
    create object o_hm.
    lo_string ?= o_hm-&gt;get( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lo_string ).
    lo_string-&gt;data = &apos;ValueOne&apos;.

    lo_string ?= o_hm-&gt;get( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lo_string ).
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;ValueOne&apos;
      act = lo_string-&gt;data
    ).
  endmethod.                    &quot;get

  method set.
    data: lo_str1 type ref to lcl_string,
          lo_str2 type ref to lcl_string.
    create object lo_str1.
    lo_str1-&gt;data = &apos;ValueOne&apos;.

    create object o_hm.

    lo_str2 ?= o_hm-&gt;get( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lo_str2 ).
    cl_aunit_assert=&gt;assert_initial( lo_str2-&gt;data ).

    o_hm-&gt;set(
      key = &apos;IdxOne&apos;
      value = lo_str1
    ).

    lo_str2 ?= o_hm-&gt;get( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lo_str2 ).
    cl_aunit_assert=&gt;assert_equals(
      exp = &apos;ValueOne&apos;
      act = lo_str2-&gt;data
    ).
  endmethod.                    &quot;set

  method exists.
    create object o_hm.
    data: lv_exists type flag.

    o_hm-&gt;new( &apos;IdxOne&apos; ).

    lv_exists = o_hm-&gt;exists( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_exists ).

    lv_exists = o_hm-&gt;exists( &apos;IdxTwo&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_exists ).
  endmethod.                    &quot;exists

  method delete.
    create object o_hm.
    o_hm-&gt;new( &apos;IdxOne&apos; ).
    o_hm-&gt;new( &apos;IdxTwo&apos; ).
    o_hm-&gt;new( &apos;IdxThree&apos; ).

    data: lv_exists type flag.
    lv_exists = o_hm-&gt;exists( &apos;IdxTwo&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_exists ).

    o_hm-&gt;delete( &apos;IdxTwo&apos; ).
    lv_exists = o_hm-&gt;exists( &apos;IdxOne&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_exists ).
    lv_exists = o_hm-&gt;exists( &apos;IdxTwo&apos; ).
    cl_aunit_assert=&gt;assert_initial( lv_exists ).
    lv_exists = o_hm-&gt;exists( &apos;IdxThree&apos; ).
    cl_aunit_assert=&gt;assert_not_initial( lv_exists ).
  endmethod.                    &quot;delete
endclass.                    &quot;abap_unit_hashmap_tests IMPLEMENTATION


*%
*%  Generated test code for the ZMARKDOWN class
*%
*%  Generated on 2015-09-14 by generate_abapunit_tests.py
*%  Do not change this code manualy!
*%
class abap_unit_zmarkdown_tests definition create private for testing.
  &quot;#AU Risk_Level Harmless
  &quot;#AU Duration   Short

  private section.
    data: markdown type ref to zmarkdown.
    methods:
      constructor,
      aesthetic_table for testing,
      aligned_table for testing,
      atx_heading for testing,
      automatic_link for testing,
      block_level_html for testing,
      code_block for testing,
      code_span for testing,
      compound_blockquote for testing,
      compound_emphasis for testing,
      compound_list for testing,
      deeply_nested_list for testing,
      email for testing,
      emphasis for testing,
      em_strong for testing,
      escaping for testing,
      fenced_code_block for testing,
      horizontal_rule for testing,
      html_comment for testing,
      html_entity for testing,
      image_reference for testing,
      image_title for testing,
      implicit_reference for testing,
      inline_link for testing,
      inline_link_title for testing,
      inline_title for testing,
      lazy_blockquote for testing,
      lazy_list for testing,
      line_break for testing,
      multiline_list_paragraph for testing,
      nested_block_level_html for testing,
      ordered_list for testing,
      paragraph_list for testing,
      reference_title for testing,
      self_closing_html for testing,
      separated_nested_list for testing,
      setext_header for testing,
      simple_blockquote for testing,
      simple_table for testing,
      span_level_html for testing,
      sparse_dense_list for testing,
      sparse_html for testing,
      sparse_list for testing,
      special_characters for testing,
      strikethrough for testing,
      strong_em for testing,
      tab_indented_code_block for testing,
      table_inline_markdown for testing,
      text_reference for testing,
      unordered_list for testing,
      untidy_table for testing,
      url_autolinking for testing,
      whitespace for testing.
endclass.                    &quot;abap_unit_zmarkdown_tests DEFINITION

*#
class abap_unit_zmarkdown_tests implementation.
  method constructor.
    create object me-&gt;markdown.
  endmethod.                    &quot;constructor

  method aesthetic_table.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;| header 1 | header 2 |&apos; %_newline &apos;| -------- | -------- |&apos; %_newline
&apos;| cell 1.1 | cell 1.2 |&apos; %_newline &apos;| cell 2.1 | cell 2.2 |&apos; into lv_markdown respecting
blanks .
    concatenate &apos;&lt;table&gt;&apos; %_newline &apos;&lt;thead&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;th&gt;header 1&lt;/th&gt;&apos;
%_newline &apos;&lt;th&gt;header 2&lt;/th&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/thead&gt;&apos; %_newline &apos;&lt;tbody&gt;&apos;
%_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.2&lt;/td&gt;&apos; %_newline
&apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;cell 2.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 2.2&lt;/td&gt;&apos;
%_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/tbody&gt;&apos; %_newline &apos;&lt;/table&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;aesthetic_table

  method aligned_table.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;| header 1 | header 2 | header 2 |&apos; %_newline
&apos;| :------- | :------: | -------: |&apos; %_newline &apos;| cell 1.1 | cell 1.2 | cell 1.3 |&apos;
%_newline &apos;| cell 2.1 | cell 2.2 | cell 2.3 |&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;table&gt;&apos; %_newline &apos;&lt;thead&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline
&apos;&lt;th style=&quot;text-align: left;&quot;&gt;header 1&lt;/th&gt;&apos; %_newline
&apos;&lt;th style=&quot;text-align: center;&quot;&gt;header 2&lt;/th&gt;&apos; %_newline
&apos;&lt;th style=&quot;text-align: right;&quot;&gt;header 2&lt;/th&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/thead&gt;&apos;
%_newline &apos;&lt;tbody&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline
&apos;&lt;td style=&quot;text-align: left;&quot;&gt;cell 1.1&lt;/td&gt;&apos; %_newline
&apos;&lt;td style=&quot;text-align: center;&quot;&gt;cell 1.2&lt;/td&gt;&apos; %_newline
&apos;&lt;td style=&quot;text-align: right;&quot;&gt;cell 1.3&lt;/td&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;tr&gt;&apos;
%_newline &apos;&lt;td style=&quot;text-align: left;&quot;&gt;cell 2.1&lt;/td&gt;&apos; %_newline
&apos;&lt;td style=&quot;text-align: center;&quot;&gt;cell 2.2&lt;/td&gt;&apos; %_newline
&apos;&lt;td style=&quot;text-align: right;&quot;&gt;cell 2.3&lt;/td&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/tbody&gt;&apos;
%_newline &apos;&lt;/table&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;aligned_table

  method atx_heading.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;# h1&apos; %_newline %_newline &apos;## h2&apos; %_newline %_newline &apos;### h3&apos; %_newline
%_newline &apos;#### h4&apos; %_newline %_newline &apos;##### h5&apos; %_newline %_newline &apos;###### h6&apos;
%_newline %_newline &apos;####### not a heading&apos; %_newline %_newline &apos;# closed h1 #&apos; %_newline
%_newline &apos;#&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;h1&gt;h1&lt;/h1&gt;&apos; %_newline &apos;&lt;h2&gt;h2&lt;/h2&gt;&apos; %_newline &apos;&lt;h3&gt;h3&lt;/h3&gt;&apos; %_newline
&apos;&lt;h4&gt;h4&lt;/h4&gt;&apos; %_newline &apos;&lt;h5&gt;h5&lt;/h5&gt;&apos; %_newline &apos;&lt;h6&gt;h6&lt;/h6&gt;&apos; %_newline
&apos;&lt;p&gt;####### not a heading&lt;/p&gt;&apos; %_newline &apos;&lt;h1&gt;closed h1&lt;/h1&gt;&apos; %_newline &apos;&lt;p&gt;#&lt;/p&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;atx_heading

  method automatic_link.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    lv_markdown = &apos;&lt;http://example.com&gt;&apos;.
    lv_expected_markup = &apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;&lt;/p&gt;&apos;.
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;automatic_link

  method block_level_html.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&lt;div&gt;_content_&lt;/div&gt;&apos; %_newline %_newline &apos;paragraph&apos; %_newline %_newline
&apos;&lt;div&gt;&apos; %_newline &apos;  &lt;div class=&quot;inner&quot;&gt;&apos; %_newline &apos;    _content_&apos; %_newline &apos;  &lt;/div&gt;&apos;
%_newline &apos;&lt;/div&gt;&apos; %_newline %_newline &apos;&lt;style type=&quot;text/css&quot;&gt;&apos; %_newline
&apos;  p {color: #789;}&apos; %_newline &apos;&lt;/style&gt;&apos; %_newline %_newline &apos;&lt;div&gt;&apos; %_newline
&apos;  &lt;a href=&quot;/&quot;&gt;home&lt;/a&gt;&lt;/div&gt;&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;div&gt;_content_&lt;/div&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;div&gt;&apos;
%_newline &apos;  &lt;div class=&quot;inner&quot;&gt;&apos; %_newline &apos;    _content_&apos; %_newline &apos;  &lt;/div&gt;&apos; %_newline
&apos;&lt;/div&gt;&apos; %_newline &apos;&lt;style type=&quot;text/css&quot;&gt;&apos; %_newline &apos;  p {color: #789;}&apos; %_newline
&apos;&lt;/style&gt;&apos; %_newline &apos;&lt;div&gt;&apos; %_newline &apos;  &lt;a href=&quot;/&quot;&gt;home&lt;/a&gt;&lt;/div&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;block_level_html

  method code_block.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;    &lt;?php&apos; %_newline %_newline &apos;    $message = &apos;&apos;Hello World!&apos;&apos;;&apos; %_newline
&apos;    echo $message;&apos; %_newline %_newline &apos;---&apos; %_newline %_newline &apos;    &gt; not a quote&apos;
%_newline &apos;    - not a list item&apos; %_newline &apos;    [not a reference]: http://foo.com&apos; into
lv_markdown respecting blanks .
    concatenate &apos;&lt;pre&gt;&lt;code&gt;&amp;lt;?php&apos; %_newline %_newline &apos;$message = &apos;&apos;Hello World!&apos;&apos;;&apos;
%_newline &apos;echo $message;&lt;/code&gt;&lt;/pre&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline
&apos;&lt;pre&gt;&lt;code&gt;&amp;gt; not a quote&apos; %_newline &apos;- not a list item&apos; %_newline
&apos;[not a reference]: http://foo.com&lt;/code&gt;&lt;/pre&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;code_block

  method code_span.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;a `code span`&apos; %_newline %_newline &apos;`this is also a codespan` trailing text&apos;
%_newline %_newline &apos;`and look at this one!`&apos; %_newline %_newline
&apos;single backtick in a code span: `` ` ``&apos; %_newline %_newline
&apos;backtick-delimited string in a code span: `` `foo` ``&apos; %_newline %_newline &apos;`sth `` sth`&apos;
into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;a &lt;code&gt;code span&lt;/code&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;code&gt;this is also a codespan&lt;/code&gt; trailing text&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;code&gt;and look at this one!&lt;/code&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;code&gt;sth `` sth&lt;/code&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;code_span

  method compound_blockquote.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&gt; header&apos; %_newline &apos;&gt; ------&apos; %_newline &apos;&gt;&apos; %_newline &apos;&gt; paragraph&apos;
%_newline &apos;&gt;&apos; %_newline &apos;&gt; - li&apos; %_newline &apos;&gt;&apos; %_newline &apos;&gt; ---&apos; %_newline &apos;&gt;&apos; %_newline
&apos;&gt; paragraph&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;blockquote&gt;&apos; %_newline &apos;&lt;h2&gt;header&lt;/h2&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos;
%_newline &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline
&apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;/blockquote&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;compound_blockquote

  method compound_emphasis.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;_`code`_ __`code`__&apos; %_newline %_newline &apos;*`code`**`code`**`code`*&apos; %_newline
into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;em&gt;&lt;code&gt;code&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;&lt;code&gt;code&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&apos;
%_newline
&apos;&lt;p&gt;&lt;em&gt;&lt;code&gt;code&lt;/code&gt;&lt;strong&gt;&lt;code&gt;code&lt;/code&gt;&lt;/strong&gt;&lt;code&gt;code&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;&apos;
into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;compound_emphasis

  method compound_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- paragraph&apos; %_newline %_newline &apos;  paragraph&apos; %_newline %_newline
&apos;- paragraph&apos; %_newline %_newline &apos;  &gt; quote&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos;
%_newline &apos;&lt;blockquote&gt;&apos; %_newline &apos;&lt;p&gt;quote&lt;/p&gt;&apos; %_newline &apos;&lt;/blockquote&gt;&apos; %_newline
&apos;&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;compound_list

  method deeply_nested_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline &apos;    - li&apos; %_newline &apos;        - li&apos; %_newline &apos;        - li&apos;
%_newline &apos;    - li&apos; %_newline &apos;- li&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&apos; %_newline &apos;&lt;ul&gt;&apos;
%_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&lt;/li&gt;&apos; %_newline
&apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;deeply_nested_list

  method email.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    lv_markdown = &apos;my email is &lt;me@example.com&gt;&apos;.
    lv_expected_markup = &apos;&lt;p&gt;my email is &lt;a href=&quot;mailto:me@example.com&quot;&gt;me@example.com&lt;/a&gt;&lt;/p&gt;&apos;.
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;email

  method emphasis.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;_underscore_, *asterisk*, _one two_, *three four*, _a_, *b*&apos; %_newline
%_newline &apos;**strong** and *em* and **strong** and *em*&apos; %_newline %_newline &apos;_line&apos;
%_newline &apos;line&apos; %_newline &apos;line_&apos; %_newline %_newline &apos;this_is_not_an_emphasis&apos; %_newline
%_newline &apos;an empty emphasis __ ** is not an emphasis&apos; %_newline %_newline
&apos;*mixed **double and* single asterisk** spans&apos; into lv_markdown respecting blanks .
    concatenate
&apos;&lt;p&gt;&lt;em&gt;underscore&lt;/em&gt;, &lt;em&gt;asterisk&lt;/em&gt;, &lt;em&gt;one two&lt;/em&gt;, &lt;em&gt;three four&lt;/em&gt;, &lt;em&gt;a&lt;/e&apos;
&apos;m&gt;, &lt;em&gt;b&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;strong&lt;/strong&gt; and &lt;em&gt;em&lt;/em&gt; and &lt;strong&gt;strong&lt;/strong&gt; and &lt;em&gt;em&lt;/em&gt;&lt;/p&gt;&apos;
%_newline &apos;&lt;p&gt;&lt;em&gt;line&apos; %_newline &apos;line&apos; %_newline &apos;line&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;this_is_not_an_emphasis&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;an empty emphasis __ ** is not an emphasis&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;*mixed *&lt;em&gt;double and&lt;/em&gt; single asterisk** spans&lt;/p&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;emphasis

  method em_strong.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;___em strong___&apos; %_newline %_newline &apos;___em strong_ strong__&apos; %_newline
%_newline &apos;__strong _em strong___&apos; %_newline %_newline &apos;__strong _em strong_ strong__&apos;
%_newline %_newline &apos;***em strong***&apos; %_newline %_newline &apos;***em strong* strong**&apos;
%_newline %_newline &apos;**strong *em strong***&apos; %_newline %_newline
&apos;**strong *em strong* strong**&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;strong&gt;&lt;em&gt;em strong&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;&lt;em&gt;em strong&lt;/em&gt; strong&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;strong &lt;em&gt;em strong&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;strong &lt;em&gt;em strong&lt;/em&gt; strong&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;&lt;em&gt;em strong&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;&lt;em&gt;em strong&lt;/em&gt; strong&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;strong &lt;em&gt;em strong&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;strong&gt;strong &lt;em&gt;em strong&lt;/em&gt; strong&lt;/strong&gt;&lt;/p&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;em_strong

  method escaping.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;escaped \*emphasis\*.&apos; %_newline %_newline
&apos;`escaped \*emphasis\* in a code span`&apos; %_newline %_newline
&apos;    escaped \*emphasis\* in a code block&apos; %_newline %_newline
&apos;\\ \` \* \_ \{ \} \[ \] \( \) \&gt; \# \+ \- \. \!&apos; %_newline %_newline
&apos;_one\_two_ __one\_two__&apos; %_newline %_newline &apos;*one\*two* **one\*two**&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;p&gt;escaped *emphasis*.&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;code&gt;escaped \*emphasis\* in a code span&lt;/code&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;pre&gt;&lt;code&gt;escaped \*emphasis\* in a code block&lt;/code&gt;&lt;/pre&gt;&apos; %_newline
&apos;&lt;p&gt;\ ` * _ { } [ ] ( ) &gt; # + - . !&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;one_two&lt;/em&gt; &lt;strong&gt;one_two&lt;/strong&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;one*two&lt;/em&gt; &lt;strong&gt;one*two&lt;/strong&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting
blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;escaping

  method fenced_code_block.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;```&apos; %_newline &apos;&lt;?php&apos; %_newline %_newline
&apos;$message = &apos;&apos;fenced code block&apos;&apos;;&apos; %_newline &apos;echo $message;&apos; %_newline &apos;```&apos; %_newline
%_newline &apos;~~~&apos; %_newline &apos;tilde&apos; %_newline &apos;~~~&apos; %_newline %_newline &apos;```php&apos; %_newline
&apos;echo &apos;&apos;language identifier&apos;&apos;;&apos; %_newline &apos;```&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;pre&gt;&lt;code&gt;&amp;lt;?php&apos; %_newline %_newline &apos;$message = &apos;&apos;fenced code block&apos;&apos;;&apos;
%_newline &apos;echo $message;&lt;/code&gt;&lt;/pre&gt;&apos; %_newline &apos;&lt;pre&gt;&lt;code&gt;tilde&lt;/code&gt;&lt;/pre&gt;&apos;
%_newline &apos;&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;echo &apos;&apos;language identifier&apos;&apos;;&lt;/code&gt;&lt;/pre&gt;&apos;
into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;fenced_code_block

  method horizontal_rule.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;---&apos; %_newline %_newline &apos;- - -&apos; %_newline %_newline &apos;   - - -&apos; %_newline
%_newline &apos;***&apos; %_newline %_newline &apos;___&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;hr /&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline
&apos;&lt;hr /&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;horizontal_rule

  method html_comment.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&lt;!-- single line --&gt;&apos; %_newline %_newline &apos;paragraph&apos; %_newline %_newline
&apos;&lt;!-- &apos; %_newline &apos;  multiline --&gt;&apos; %_newline %_newline &apos;paragraph&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;!-- single line --&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;!-- &apos;
%_newline &apos;  multiline --&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;html_comment

  method html_entity.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    lv_markdown = &apos;&amp;amp; &amp;copy; &amp;#123;&apos;.
    lv_expected_markup = &apos;&lt;p&gt;&amp;amp; &amp;copy; &amp;#123;&lt;/p&gt;&apos;.
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;html_entity

  method image_reference.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;![Markdown Logo][image]&apos; %_newline %_newline &apos;[image]: /md.png&apos; %_newline
%_newline &apos;![missing reference]&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;img src=&quot;/md.png&quot; alt=&quot;Markdown Logo&quot; /&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;![missing reference]&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;image_reference

  method image_title.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;![alt](/md.png &quot;title&quot;)&apos; %_newline %_newline &apos;![blank title](/md.png &quot;&quot;)&apos;
into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;img src=&quot;/md.png&quot; alt=&quot;alt&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;img src=&quot;/md.png&quot; alt=&quot;blank title&quot; title=&quot;&quot; /&gt;&lt;/p&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;image_title

  method implicit_reference.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;an [implicit] reference link&apos; %_newline %_newline
&apos;[implicit]: http://example.com&apos; %_newline %_newline
&apos;an [implicit][] reference link with an empty link definition&apos; %_newline %_newline
&apos;an [implicit][] reference link followed by [another][]&apos; %_newline %_newline
&apos;[another]: http://cnn.com&apos; %_newline %_newline
&apos;an [explicit][example] reference link with a title&apos; %_newline %_newline
&apos;[example]: http://example.com &quot;Example&quot;&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;an &lt;a href=&quot;http://example.com&quot;&gt;implicit&lt;/a&gt; reference link&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;an &lt;a href=&quot;http://example.com&quot;&gt;implicit&lt;/a&gt; reference link with an empty link definiti&apos;
&apos;on&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;an &lt;a href=&quot;http://example.com&quot;&gt;implicit&lt;/a&gt; reference link followed by &lt;a href=&quot;http:/&apos;
&apos;/cnn.com&quot;&gt;another&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;an &lt;a href=&quot;http://example.com&quot; title=&quot;Example&quot;&gt;explicit&lt;/a&gt; reference link with a titl&apos;
&apos;e&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;implicit_reference

  method inline_link.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;[link](http://example.com)&apos; %_newline %_newline
&apos;[link](/url-(parentheses)) with parentheses in URL &apos; %_newline %_newline
&apos;([link](/index.php)) in parentheses&apos; %_newline %_newline &apos;[`link`](http://example.com)&apos;
%_newline %_newline &apos;[![MD Logo](http://parsedown.org/md.png)](http://example.com)&apos;
%_newline %_newline
&apos;[![MD Logo](http://parsedown.org/md.png) and text](http://example.com)&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;link&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;/url-(parentheses)&quot;&gt;link&lt;/a&gt; with parentheses in URL &lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;(&lt;a href=&quot;/index.php&quot;&gt;link&lt;/a&gt;) in parentheses&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;&lt;code&gt;link&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;&lt;img src=&quot;http://parsedown.org/md.png&quot; alt=&quot;MD Logo&quot; /&gt;&lt;/a&apos;
&apos;&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;&lt;img src=&quot;http://parsedown.org/md.png&quot; alt=&quot;MD Logo&quot; /&gt; an&apos;
&apos;d text&lt;/a&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;inline_link

  method inline_link_title.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;[single quotes](http://example.com &apos;&apos;Title&apos;&apos;)&apos; %_newline %_newline
&apos;[double quotes](http://example.com &quot;Title&quot;)&apos; %_newline %_newline
&apos;[single quotes blank](http://example.com &apos;&apos;&apos;&apos;)&apos; %_newline %_newline
&apos;[double quotes blank](http://example.com &quot;&quot;)&apos; %_newline %_newline
&apos;[space](http://example.com &quot;2 Words&quot;)&apos; %_newline %_newline
&apos;[parentheses](http://example.com/url-(parentheses) &quot;Title&quot;)&apos; into lv_markdown respecting
blanks .
    concatenate &apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;Title&quot;&gt;single quotes&lt;/a&gt;&lt;/p&gt;&apos;
%_newline &apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;Title&quot;&gt;double quotes&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;&quot;&gt;single quotes blank&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;&quot;&gt;double quotes blank&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;2 Words&quot;&gt;space&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com/url-(parentheses)&quot; title=&quot;Title&quot;&gt;parentheses&lt;/a&gt;&lt;/p&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;inline_link_title

  method inline_title.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate
&apos;[single quotes](http://example.com &apos;&apos;Example&apos;&apos;) and [double quotes](http://example.com &quot;Exam&apos;
&apos;ple&quot;)&apos; into lv_markdown respecting blanks .
    concatenate
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;Example&quot;&gt;single quotes&lt;/a&gt; and &lt;a href=&quot;http://exam&apos;
&apos;ple.com&quot; title=&quot;Example&quot;&gt;double quotes&lt;/a&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;inline_title

  method lazy_blockquote.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&gt; quote&apos; %_newline &apos;the rest of it&apos; %_newline %_newline &apos;&gt; another paragraph&apos;
%_newline &apos;the rest of it&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;blockquote&gt;&apos; %_newline &apos;&lt;p&gt;quote&apos; %_newline &apos;the rest of it&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;another paragraph&apos; %_newline &apos;the rest of it&lt;/p&gt;&apos; %_newline &apos;&lt;/blockquote&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;lazy_blockquote

  method lazy_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline &apos;the rest of it&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&apos; %_newline &apos;the rest of it&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos;
into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;lazy_list

  method line_break.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;line  &apos; %_newline &apos;line&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;line&lt;br /&gt;&apos; %_newline &apos;line&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;line_break

  method multiline_list_paragraph.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline %_newline &apos;  line&apos; %_newline &apos;  line&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;li&lt;/p&gt;&apos; %_newline &apos;&lt;p&gt;line&apos; %_newline
&apos;line&lt;/p&gt;&apos; %_newline &apos;&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;multiline_list_paragraph

  method nested_block_level_html.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&lt;div&gt;&apos; %_newline &apos;_parent_&apos; %_newline &apos;&lt;div&gt;&apos; %_newline &apos;_child_&apos; %_newline
&apos;&lt;/div&gt;&apos; %_newline &apos;&lt;pre&gt;&apos; %_newline &apos;_adopted child_&apos; %_newline &apos;&lt;/pre&gt;&apos; %_newline
&apos;&lt;/div&gt;&apos; %_newline %_newline &apos;_outside_&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;div&gt;&apos; %_newline &apos;_parent_&apos; %_newline &apos;&lt;div&gt;&apos; %_newline &apos;_child_&apos; %_newline
&apos;&lt;/div&gt;&apos; %_newline &apos;&lt;pre&gt;&apos; %_newline &apos;_adopted child_&apos; %_newline &apos;&lt;/pre&gt;&apos; %_newline
&apos;&lt;/div&gt;&apos; %_newline &apos;&lt;p&gt;&lt;em&gt;outside&lt;/em&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;nested_block_level_html

  method ordered_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;1. one&apos; %_newline &apos;2. two&apos; %_newline %_newline &apos;repeating numbers:&apos; %_newline
%_newline &apos;1. one&apos; %_newline &apos;1. two&apos; %_newline %_newline &apos;large numbers:&apos; %_newline
%_newline &apos;123. one&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;ol&gt;&apos; %_newline &apos;&lt;li&gt;one&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;two&lt;/li&gt;&apos; %_newline &apos;&lt;/ol&gt;&apos;
%_newline &apos;&lt;p&gt;repeating numbers:&lt;/p&gt;&apos; %_newline &apos;&lt;ol&gt;&apos; %_newline &apos;&lt;li&gt;one&lt;/li&gt;&apos; %_newline
&apos;&lt;li&gt;two&lt;/li&gt;&apos; %_newline &apos;&lt;/ol&gt;&apos; %_newline &apos;&lt;p&gt;large numbers:&lt;/p&gt;&apos; %_newline &apos;&lt;ol&gt;&apos;
%_newline &apos;&lt;li&gt;one&lt;/li&gt;&apos; %_newline &apos;&lt;/ol&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;ordered_list

  method paragraph_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;paragraph&apos; %_newline &apos;- li&apos; %_newline &apos;- li&apos; %_newline %_newline &apos;paragraph&apos;
%_newline %_newline &apos;   * li&apos; %_newline &apos;   &apos; %_newline &apos;   * li&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline
&apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline
&apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;li&lt;/p&gt;&apos; %_newline &apos;&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos;
into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;paragraph_list

  method reference_title.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;[double quotes] and [single quotes] and [parentheses]&apos; %_newline %_newline
&apos;[double quotes]: http://example.com &quot;example title&quot;&apos; %_newline
&apos;[single quotes]: http://example.com &apos;&apos;example title&apos;&apos;&apos; %_newline
&apos;[parentheses]: http://example.com (example title)&apos; %_newline
&apos;[invalid title]: http://example.com example title&apos; into lv_markdown respecting blanks .
    concatenate
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot; title=&quot;example title&quot;&gt;double quotes&lt;/a&gt; and &lt;a href=&quot;http:&apos;
&apos;//example.com&quot; title=&quot;example title&quot;&gt;single quotes&lt;/a&gt; and &lt;a href=&quot;http://example.com&quot; ti&apos;
&apos;tle=&quot;example title&quot;&gt;parentheses&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;[invalid title]: &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt; example title&lt;/p&gt;&apos;
into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;reference_title

  method self_closing_html.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&lt;hr&gt;&apos; %_newline &apos;paragraph&apos; %_newline &apos;&lt;hr/&gt;&apos; %_newline &apos;paragraph&apos; %_newline
&apos;&lt;hr /&gt;&apos; %_newline &apos;paragraph&apos; %_newline &apos;&lt;hr class=&quot;foo&quot; id=&quot;bar&quot; /&gt;&apos; %_newline
&apos;paragraph&apos; %_newline &apos;&lt;hr class=&quot;foo&quot; id=&quot;bar&quot;/&gt;&apos; %_newline &apos;paragraph&apos; %_newline
&apos;&lt;hr class=&quot;foo&quot; id=&quot;bar&quot; &gt;&apos; %_newline &apos;paragraph&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;hr&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;hr/&gt;&apos; %_newline
&apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline
&apos;&lt;hr class=&quot;foo&quot; id=&quot;bar&quot; /&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline
&apos;&lt;hr class=&quot;foo&quot; id=&quot;bar&quot;/&gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; %_newline
&apos;&lt;hr class=&quot;foo&quot; id=&quot;bar&quot; &gt;&apos; %_newline &apos;&lt;p&gt;paragraph&lt;/p&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;self_closing_html

  method separated_nested_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline %_newline &apos;    - li&apos; %_newline &apos;    - li&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;li&lt;/p&gt;&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline
&apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; %_newline &apos;&lt;/li&gt;&apos; %_newline
&apos;&lt;/ul&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;separated_nested_list

  method setext_header.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;h1&apos; %_newline &apos;==&apos; %_newline %_newline &apos;h2&apos; %_newline &apos;--&apos; %_newline
%_newline &apos;single character&apos; %_newline &apos;-&apos; %_newline %_newline &apos;not a header&apos; %_newline
%_newline &apos;------------&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;h1&gt;h1&lt;/h1&gt;&apos; %_newline &apos;&lt;h2&gt;h2&lt;/h2&gt;&apos; %_newline &apos;&lt;h2&gt;single character&lt;/h2&gt;&apos;
%_newline &apos;&lt;p&gt;not a header&lt;/p&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; into lv_expected_markup respecting
blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;setext_header

  method simple_blockquote.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&gt; quote&apos; %_newline %_newline &apos;indented:&apos; %_newline &apos;   &gt; quote&apos; %_newline
%_newline &apos;no space after `&gt;`:&apos; %_newline &apos;&gt;quote&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;blockquote&gt;&apos; %_newline &apos;&lt;p&gt;quote&lt;/p&gt;&apos; %_newline &apos;&lt;/blockquote&gt;&apos; %_newline
&apos;&lt;p&gt;indented:&lt;/p&gt;&apos; %_newline &apos;&lt;blockquote&gt;&apos; %_newline &apos;&lt;p&gt;quote&lt;/p&gt;&apos; %_newline
&apos;&lt;/blockquote&gt;&apos; %_newline &apos;&lt;p&gt;no space after &lt;code&gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;&apos; %_newline
&apos;&lt;blockquote&gt;&apos; %_newline &apos;&lt;p&gt;quote&lt;/p&gt;&apos; %_newline &apos;&lt;/blockquote&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;simple_blockquote

  method simple_table.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;header 1 | header 2&apos; %_newline &apos;-------- | --------&apos; %_newline
&apos;cell 1.1 | cell 1.2&apos; %_newline &apos;cell 2.1 | cell 2.2&apos; %_newline %_newline &apos;---&apos; %_newline
%_newline &apos;header 1 | header 2&apos; %_newline &apos;:------- | --------&apos; %_newline
&apos;cell 1.1 | cell 1.2&apos; %_newline &apos;cell 2.1 | cell 2.2&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;table&gt;&apos; %_newline &apos;&lt;thead&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;th&gt;header 1&lt;/th&gt;&apos;
%_newline &apos;&lt;th&gt;header 2&lt;/th&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/thead&gt;&apos; %_newline &apos;&lt;tbody&gt;&apos;
%_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.2&lt;/td&gt;&apos; %_newline
&apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;cell 2.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 2.2&lt;/td&gt;&apos;
%_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/tbody&gt;&apos; %_newline &apos;&lt;/table&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline
&apos;&lt;table&gt;&apos; %_newline &apos;&lt;thead&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline
&apos;&lt;th style=&quot;text-align: left;&quot;&gt;header 1&lt;/th&gt;&apos; %_newline &apos;&lt;th&gt;header 2&lt;/th&gt;&apos; %_newline
&apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/thead&gt;&apos; %_newline &apos;&lt;tbody&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline
&apos;&lt;td style=&quot;text-align: left;&quot;&gt;cell 1.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.2&lt;/td&gt;&apos; %_newline
&apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td style=&quot;text-align: left;&quot;&gt;cell 2.1&lt;/td&gt;&apos; %_newline
&apos;&lt;td&gt;cell 2.2&lt;/td&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/tbody&gt;&apos; %_newline &apos;&lt;/table&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;simple_table

  method span_level_html.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;an &lt;b&gt;important&lt;/b&gt; &lt;a href=&apos;&apos;&apos;&apos;&gt;link&lt;/a&gt;&apos; %_newline %_newline &apos;broken&lt;br/&gt;&apos;
%_newline &apos;line&apos; %_newline %_newline &apos;&lt;b&gt;inline tag&lt;/b&gt; at the beginning&apos; %_newline
%_newline &apos;&lt;span&gt;http://example.com&lt;/span&gt;&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;an &lt;b&gt;important&lt;/b&gt; &lt;a href=&apos;&apos;&apos;&apos;&gt;link&lt;/a&gt;&lt;/p&gt;&apos; %_newline &apos;&lt;p&gt;broken&lt;br/&gt;&apos;
%_newline &apos;line&lt;/p&gt;&apos; %_newline &apos;&lt;p&gt;&lt;b&gt;inline tag&lt;/b&gt; at the beginning&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;span_level_html

  method sparse_dense_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline %_newline &apos;- li&apos; %_newline &apos;- li&apos; into lv_markdown respecting
blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;li&lt;/p&gt;&apos; %_newline &apos;&lt;/li&gt;&apos; %_newline
&apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; into lv_expected_markup respecting
blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;sparse_dense_list

  method sparse_html.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&lt;div&gt;&apos; %_newline &apos;line 1&apos; %_newline %_newline &apos;line 2&apos; %_newline &apos;line 3&apos;
%_newline %_newline &apos;line 4&apos; %_newline &apos;&lt;/div&gt;&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;div&gt;&apos; %_newline &apos;line 1&apos; %_newline %_newline &apos;line 2&apos; %_newline &apos;line 3&apos;
%_newline %_newline &apos;line 4&apos; %_newline &apos;&lt;/div&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;sparse_html

  method sparse_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline %_newline &apos;- li&apos; %_newline %_newline &apos;---&apos; %_newline
%_newline &apos;- li&apos; %_newline %_newline &apos;    - indented li&apos; into lv_markdown respecting
blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;&apos; %_newline &apos;&lt;p&gt;li&lt;/p&gt;&apos; %_newline &apos;&lt;/li&gt;&apos; %_newline
&apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; %_newline &apos;&lt;hr /&gt;&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;&apos;
%_newline &apos;&lt;p&gt;li&lt;/p&gt;&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;indented li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos;
%_newline &apos;&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;sparse_list

  method special_characters.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;AT&amp;T has an ampersand in their name&apos; %_newline %_newline &apos;this &amp; that&apos;
%_newline %_newline &apos;4 &lt; 5 and 6 &gt; 5&apos; %_newline %_newline
&apos;&lt;http://example.com/autolink?a=1&amp;b=2&gt;&apos; %_newline %_newline
&apos;[inline link](/script?a=1&amp;b=2)&apos; %_newline %_newline &apos;[reference link][1]&apos; %_newline
%_newline &apos;[1]: http://example.com/?a=1&amp;b=2&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;AT&amp;amp;T has an ampersand in their name&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;this &amp;amp; that&lt;/p&gt;&apos; %_newline &apos;&lt;p&gt;4 &amp;lt; 5 and 6 &amp;gt; 5&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com/autolink?a=1&amp;amp;b=2&quot;&gt;http://example.com/autolink?a=1&amp;amp;b&apos;
&apos;=2&lt;/a&gt;&lt;/p&gt;&apos; %_newline &apos;&lt;p&gt;&lt;a href=&quot;/script?a=1&amp;amp;b=2&quot;&gt;inline link&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com/?a=1&amp;amp;b=2&quot;&gt;reference link&lt;/a&gt;&lt;/p&gt;&apos; into
lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;special_characters

  method strikethrough.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;~~strikethrough~~&apos; %_newline %_newline
&apos;here&apos;&apos;s ~~one~~ followed by ~~another one~~&apos; %_newline %_newline
&apos;~~ this ~~ is not one neither is ~this~&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;del&gt;strikethrough&lt;/del&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;here&apos;&apos;s &lt;del&gt;one&lt;/del&gt; followed by &lt;del&gt;another one&lt;/del&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;~~ this ~~ is not one neither is ~this~&lt;/p&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;strikethrough

  method strong_em.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;*em **strong em***&apos; %_newline %_newline &apos;***strong em** em*&apos; %_newline
%_newline &apos;*em **strong em** em*&apos; %_newline %_newline &apos;_em __strong em___&apos; %_newline
%_newline &apos;___strong em__ em_&apos; %_newline %_newline &apos;_em __strong em__ em_&apos; into
lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;em&gt;em &lt;strong&gt;strong em&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;&lt;strong&gt;strong em&lt;/strong&gt; em&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;em &lt;strong&gt;strong em&lt;/strong&gt; em&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;em &lt;strong&gt;strong em&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;&lt;strong&gt;strong em&lt;/strong&gt; em&lt;/em&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;em&gt;em &lt;strong&gt;strong em&lt;/strong&gt; em&lt;/em&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting
blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;strong_em

  method tab_indented_code_block.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;&apos; %_horizontal_tab &apos;&lt;?php&apos; %_newline &apos;&apos; %_horizontal_tab &apos;&apos; %_newline
&apos;&apos; %_horizontal_tab &apos;$message = &apos;&apos;Hello World!&apos;&apos;;&apos; %_newline
&apos;&apos; %_horizontal_tab &apos;echo $message;&apos; %_newline %_newline
&apos;&apos; %_horizontal_tab &apos;echo &quot;following a blank line&quot;;&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;pre&gt;&lt;code&gt;&amp;lt;?php&apos; %_newline %_newline &apos;$message = &apos;&apos;Hello World!&apos;&apos;;&apos;
%_newline &apos;echo $message;&apos; %_newline %_newline
&apos;echo &quot;following a blank line&quot;;&lt;/code&gt;&lt;/pre&gt;&apos; into lv_expected_markup respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;tab_indented_code_block

  method table_inline_markdown.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;| _header_ 1   | header 2     |&apos; %_newline &apos;| ------------ | ------------ |&apos;
%_newline &apos;| _cell_ 1.1   | ~~cell~~ 1.2 |&apos; %_newline &apos;| `|` 2.1      | \| 2.2       |&apos;
%_newline &apos;| `\|` 2.1     | [link](/)    |&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;table&gt;&apos; %_newline &apos;&lt;thead&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline
&apos;&lt;th&gt;&lt;em&gt;header&lt;/em&gt; 1&lt;/th&gt;&apos; %_newline &apos;&lt;th&gt;header 2&lt;/th&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline
&apos;&lt;/thead&gt;&apos; %_newline &apos;&lt;tbody&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;&lt;em&gt;cell&lt;/em&gt; 1.1&lt;/td&gt;&apos;
%_newline &apos;&lt;td&gt;&lt;del&gt;cell&lt;/del&gt; 1.2&lt;/td&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline
&apos;&lt;td&gt;&lt;code&gt;|&lt;/code&gt; 2.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;| 2.2&lt;/td&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline
&apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;&lt;code&gt;\|&lt;/code&gt; 2.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;&lt;a href=&quot;/&quot;&gt;link&lt;/a&gt;&lt;/td&gt;&apos;
%_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/tbody&gt;&apos; %_newline &apos;&lt;/table&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;table_inline_markdown

  method text_reference.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;[reference link][1]&apos; %_newline %_newline &apos;[1]: http://example.com&apos; %_newline
%_newline &apos;[one][website] with a semantic name&apos; %_newline %_newline
&apos;[website]: http://example.com&apos; %_newline %_newline &apos;[one][404] with no definition&apos;
%_newline %_newline &apos;[multiline&apos; %_newline &apos;one][website] defined on 2 lines&apos; %_newline
%_newline &apos;[one][Label] with a mixed case label and an upper case definition&apos; %_newline
%_newline &apos;[LABEL]: http://example.com&apos; %_newline %_newline &apos;[one]&apos; %_newline
&apos;[1] with the a label on the next line&apos; %_newline %_newline &apos;[`link`][website]&apos; into
lv_markdown respecting blanks .
    concatenate &apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;reference link&lt;/a&gt;&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;one&lt;/a&gt; with a semantic name&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;[one][404] with no definition&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;multiline&apos; %_newline &apos;one&lt;/a&gt; defined on 2 lines&lt;/p&gt;&apos;
%_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;one&lt;/a&gt; with a mixed case label and an upper case definiti&apos;
&apos;on&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;one&lt;/a&gt; with the a label on the next line&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;&lt;a href=&quot;http://example.com&quot;&gt;&lt;code&gt;link&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;text_reference

  method unordered_list.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;- li&apos; %_newline &apos;- li&apos; %_newline %_newline &apos;mixed markers:&apos; %_newline
%_newline &apos;* li&apos; %_newline &apos;+ li&apos; %_newline &apos;- li&apos; into lv_markdown respecting blanks .
    concatenate &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos;
%_newline &apos;&lt;p&gt;mixed markers:&lt;/p&gt;&apos; %_newline &apos;&lt;ul&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline
&apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;li&gt;li&lt;/li&gt;&apos; %_newline &apos;&lt;/ul&gt;&apos; into lv_expected_markup respecting
blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;unordered_list

  method untidy_table.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;| header 1 | header 2          |&apos; %_newline &apos;| ------------- | ----------- |&apos;
%_newline &apos;| cell 1.1   | cell 1.2 |&apos; %_newline &apos;|    cell 2.1 | cell 2.2     |&apos; into
lv_markdown respecting blanks .
    concatenate &apos;&lt;table&gt;&apos; %_newline &apos;&lt;thead&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;th&gt;header 1&lt;/th&gt;&apos;
%_newline &apos;&lt;th&gt;header 2&lt;/th&gt;&apos; %_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/thead&gt;&apos; %_newline &apos;&lt;tbody&gt;&apos;
%_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 1.2&lt;/td&gt;&apos; %_newline
&apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;tr&gt;&apos; %_newline &apos;&lt;td&gt;cell 2.1&lt;/td&gt;&apos; %_newline &apos;&lt;td&gt;cell 2.2&lt;/td&gt;&apos;
%_newline &apos;&lt;/tr&gt;&apos; %_newline &apos;&lt;/tbody&gt;&apos; %_newline &apos;&lt;/table&gt;&apos; into lv_expected_markup
respecting blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;untidy_table

  method url_autolinking.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;an autolink http://example.com&apos; %_newline %_newline
&apos;inside of brackets [http://example.com], inside of braces {http://example.com},  inside of&apos;
&apos; parentheses (http://example.com)&apos; %_newline %_newline
&apos;trailing slash http://example.com/ and http://example.com/path/&apos; into lv_markdown
respecting blanks .
    concatenate &apos;&lt;p&gt;an autolink &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;&lt;/p&gt;&apos;
%_newline
&apos;&lt;p&gt;inside of brackets [&lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;], inside of bra&apos;
&apos;ces {&lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;},  inside of parentheses (&lt;a href&apos;
&apos;=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;)&lt;/p&gt;&apos; %_newline
&apos;&lt;p&gt;trailing slash &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; and &lt;a href=&quot;http:&apos;
&apos;//example.com/path/&quot;&gt;http://example.com/path/&lt;/a&gt;&lt;/p&gt;&apos; into lv_expected_markup respecting
blanks .
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;url_autolinking

  method whitespace.
    data: lv_markdown type string,
          lv_expected_markup type string,
          lv_actual_markup type string.
    concatenate &apos;    &apos; %_newline %_newline &apos;    code&apos; %_newline %_newline &apos;    &apos; into
lv_markdown respecting blanks .
    lv_expected_markup = &apos;&lt;pre&gt;&lt;code&gt;code&lt;/code&gt;&lt;/pre&gt;&apos;.
    lv_actual_markup = me-&gt;markdown-&gt;text( lv_markdown ).
    cl_aunit_assert=&gt;assert_equals(
      act = lv_actual_markup
      exp = lv_expected_markup
    ).
  endmethod.                    &quot;whitespace
endclass.                    &quot;abap_unit_zmarkdown_tests IMPLEMENTATION</localTestClasses>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TYPES" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_HASHMAP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="BREAKS_ENABLED" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="DEFINITION_DATA" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_HASHMAP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="EM_REGEX" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_HASHMAP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="INLINE_MARKER_LIST" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTVALUE="&apos;!&quot;*_&amp;[:&lt;&gt;`~\\&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="INLINE_TYPES" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_HASHMAP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="MARKUP_ESCAPED" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="METHODS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="136 " SRCCOLUMN1="4 " SRCROW2="136 " SRCCOLUMN2="40 " TYPESRC_LENG="39 " TYPESRC="methods type standard table of string
"/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="REGEX_HTML_ATTRIBUTE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTVALUE="&apos;[a-zA-Z_:][\w:.-]*(?:\s*=\s*(?:[^&quot;&apos;&apos;=&lt;&gt;`\s]+|&quot;[^&quot;]*&quot;|&apos;&apos;[^&apos;&apos;]*&apos;&apos;))?&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="SPECIAL_CHARACTERS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_STRING_ARRAY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="STRONG_REGEX" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_HASHMAP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="TEXT_LEVEL_ELEMENTS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_STRING_ARRAY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="UNMARKED_BLOCK_TYPES" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_STRING_ARRAY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="URLS_LINKED" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTVALUE="&apos;X&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="VERSION" VERSION="1" LANGU="P" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;1.0.0&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZMARKDOWN" CMPNAME="VOID_ELEMENTS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="LCL_STRING_ARRAY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_code.
    if block is not initial and
       block-type is initial and
       block-interrupted is initial.
      return.
    endif.

    if line-indent &gt;= 4.
      r_block-element-name = &apos;pre&apos;.
      r_block-element-handler = &apos;element&apos;.
      r_block-element-text-name = &apos;code&apos;.
      r_block-element-text-text = line-body+4.
    endif.
  endmethod.                    &quot;block_code</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_COMPLETE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_COMPLETE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_COMPLETE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_code_complete.
    r_block = block.
    r_block-element-text-text = htmlspecialchars( r_block-element-text-text ).
  endmethod.                    &quot;block_code_complete</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_CODE_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_code_continue.
    data: lv_text type string.

    if line-indent &gt;= 4.
      r_block = block.

      if block-interrupted is not initial.
        concatenate r_block-element-text-text %_newline
          into r_block-element-text-text respecting blanks.
        clear r_block-interrupted.
      endif.

      lv_text = line-body+4.
      concatenate r_block-element-text-text %_newline lv_text
        into r_block-element-text-text respecting blanks.
    endif.
  endmethod.                    &quot;block_code_continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_comment.
    check me-&gt;markup_escaped is initial.

    if strlen( line-text ) &gt;= 3 and
       line-text+3(1) = &apos;-&apos; and
       line-text+2(1) = &apos;-&apos; and
       line-text+1(1) = &apos;!&apos;.
      r_block-markup = line-body.

      find regex &apos;--&gt;$&apos; in line-text.
      if sy-subrc = 0.
        r_block-closed = &apos;X&apos;.
      endif.
    endif.
  endmethod.                    &quot;block_Comment</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_COMMENT_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_comment_continue.
    check block-closed is initial.
    r_block = block.

    concatenate r_block-markup %_newline line-body into r_block-markup.

    find regex &apos;--&gt;$&apos; in line-text.
    if sy-subrc = 0.
      r_block-closed = &apos;X&apos;.
    endif.
  endmethod.                    &quot;block_Comment_Continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_fencedcode.
    data: lv_regex type string,
          lv_m1 type string.

    field-symbols: &lt;attribute&gt; like line of r_block-element-text-attributes.

    concatenate &apos;^[&apos; line-text(1) &apos;]{3,}[ ]*([\w-]+)?[ ]*$&apos; into lv_regex.
    find regex lv_regex in line-text submatches lv_m1.
    if sy-subrc = 0.
      if lv_m1 is not initial.
        append initial line to r_block-element-text-attributes assigning &lt;attribute&gt;.
        &lt;attribute&gt;-name = &apos;class&apos;.
        concatenate &apos;language-&apos; lv_m1 into &lt;attribute&gt;-value.
      endif.

      r_block-char = line-text(1).
      r_block-element-name = &apos;pre&apos;.
      r_block-element-handler = &apos;element&apos;.
      r_block-element-text-name = &apos;code&apos;.
    endif.
  endmethod.                    &quot;block_Fenced_Code</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_COMPLETE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_COMPLETE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_COMPLETE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_fencedcode_complete.
    r_block = block.
    r_block-element-text-text = htmlspecialchars( r_block-element-text-text ).
  endmethod.                    &quot;block_Fenced_Code_Complete</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_FENCEDCODE_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_fencedcode_continue.
    data: lv_regex type string.

    check block-complete is initial.
    r_block = block.

    if r_block-interrupted is not initial.
      concatenate r_block-element-text-text %_newline into r_block-element-text-text.
      clear r_block-interrupted.
    endif.

    concatenate &apos;^&apos; block-char &apos;{3,}[ ]*$&apos; into lv_regex.
    find regex lv_regex in line-text.
    if sy-subrc = 0.
      r_block-element-text-text = r_block-element-text-text+1.
      r_block-complete = &apos;X&apos;.
      return.
    endif.

    concatenate
      r_block-element-text-text %_newline line-body
      into r_block-element-text-text.
  endmethod.                    &quot;block_Fenced_Code_Continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_HEADER" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_HEADER" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_HEADER" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_HEADER" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_header.
    check strlen( line-text ) &gt; 1 and line-text+1(1) is not initial.

    data: lv_level type i value 1,
          lv_h_level type n.

    while ( lv_level &lt; strlen( line-text ) and
            line-text+lv_level(1) = &apos;#&apos; ).
      add 1 to lv_level.
    endwhile.

    check not lv_level &gt; 6.
    lv_h_level = lv_level.
    concatenate &apos;h&apos; lv_h_level into r_block-element-name.
    r_block-element-text-text = line-text.
    r_block-element-text-text = trim( str = r_block-element-text-text mask = &apos; #&apos; ).
    condense r_block-element-text-text.
    r_block-element-handler = &apos;line&apos;.
  endmethod.                    &quot;block_Header</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_list.
    data: lv_name type string,
          lv_pattern type string,
          lv_regex type string,
          lv_m1 type string, &quot;#EC needed
          lv_m2 type string.

    if line-text(1) &lt;= &apos;-&apos;.
      lv_name = &apos;ul&apos;.
      lv_pattern = &apos;[*+-]&apos;.
    else.
      lv_name = &apos;ol&apos;.
      lv_pattern = &apos;[0-9]+[.]&apos;.
    endif.

    concatenate &apos;^(&apos; lv_pattern &apos;[ ]+)(.*)&apos; into lv_regex.
    find regex lv_regex in line-text submatches lv_m1 lv_m2.
    if sy-subrc = 0.
      r_block-indent = line-indent.
      r_block-pattern = lv_pattern.
      r_block-element-name = lv_name.
      r_block-element-handler = &apos;elements&apos;.

      r_block-li-name = &apos;li&apos;.
      r_block-li-handler = &apos;li&apos;.
      append lv_m2 to r_block-li-lines.
    endif.
  endmethod.                    &quot;block_List</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_COMPLETE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_COMPLETE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_COMPLETE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_list_complete.
    r_block = block.
    append r_block-li to r_block-element-texts.
  endmethod.                    &quot;block_List_complete</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_LIST_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_list_continue.
    data: lv_regex type string,
          lv_m1 type string,
          ls_block type ty_block,
          lv_text type string.

    r_block = block.

    concatenate &apos;^&apos; block-pattern &apos;(?:[ ]+(.*)|$)&apos; into lv_regex.
    if block-indent = line-indent.
      find regex lv_regex in line-text submatches lv_m1.
      if sy-subrc = 0.
        if r_block-interrupted is not initial.
          append initial line to r_block-li-lines.
          clear r_block-interrupted.
        endif.
        append r_block-li to r_block-element-texts.

        clear r_block-li.
        r_block-li-name = &apos;li&apos;.
        r_block-li-handler = &apos;li&apos;.
        append lv_m1 to r_block-li-lines.
        return.
      endif.
    endif.

    if line-text(1) = &apos;[&apos;.
      ls_block = block_reference( line ).
      if ls_block is not initial.
        return.
      endif.
    endif.

    if r_block-interrupted is initial.
      lv_text = line-body.
      replace all occurrences of regex &apos;^[ ]{0,4}&apos; in lv_text with &apos;&apos;.
      append lv_text to r_block-li-lines.
      return.
    endif.

    if line-indent &gt; 0.
      append initial line to r_block-li-lines.
      lv_text = line-body.
      replace all occurrences of regex &apos;^[ ]{0,4}&apos; in lv_text with &apos;&apos;.
      append lv_text to r_block-li-lines.
      clear r_block-interrupted.
      return.
    endif.

    clear r_block.
  endmethod.                    &quot;block_List_Continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="23 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_markup.
    check me-&gt;markup_escaped is initial.

    data: lv_regex type string,
          lv_m1 type string,
          lv_m2 type string,
          lv_index type i,
          lv_length type i,
          lv_remainder type string,
          lv_remainder_trimmed type string.

    concatenate &apos;^&lt;(\w*)(?:[ ]*&apos; me-&gt;regex_html_attribute &apos;)*[ ]*(/)?&gt;&apos; into lv_regex.
    find first occurrence of regex lv_regex in line-text submatches lv_m1 lv_m2
      match length lv_length.
    if sy-subrc = 0.

      lv_index = me-&gt;text_level_elements-&gt;find( lv_m1 ).
      check lv_index = 0.

      r_block-name = lv_m1.
      r_block-depth = 0.
      r_block-markup = line-text.

      lv_remainder = line-text+lv_length.
      lv_remainder_trimmed = trim( lv_remainder ).

      lv_index = me-&gt;void_elements-&gt;find( lv_m1 ).

      if lv_remainder_trimmed is initial.
        if lv_m2 is not initial or lv_index &lt;&gt; 0.
          r_block-closed = &apos;X&apos;.
          r_block-void = &apos;X&apos;.
        endif.
      else.
        if lv_m2 is not initial or lv_index &lt;&gt; 0.
          clear r_block.
          return.
        endif.

        concatenate &apos;&lt;/&apos; lv_m1 &apos;&gt;[ ]*$&apos; into lv_regex.
        find first occurrence of regex lv_regex in lv_remainder ignoring case.
        if sy-subrc = 0.
          r_block-closed = &apos;X&apos;.
        endif.
      endif.

    endif. &quot;regex sy-subrc = 0
  endmethod.                    &quot;block_Markup</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="24 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_MARKUP_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_markup_continue.
    data: lv_regex type string.

    check block-closed is initial.
    r_block = block.

    concatenate &apos;^&lt;&apos; r_block-name &apos;(?:[ ]*&apos; me-&gt;regex_html_attribute &apos;)*[ ]*&gt;&apos; into lv_regex.
    find regex lv_regex in line-text ignoring case. &quot;open
    if sy-subrc = 0.
      add 1 to r_block-depth.
    endif.

    concatenate &apos;&lt;/&apos; r_block-name &apos;&gt;[ ]*$&apos; into lv_regex.
    find regex lv_regex in line-text ignoring case. &quot;close
    if sy-subrc = 0.
      if r_block-depth &gt; 0.
        subtract 1 from r_block-depth.
      else.
        r_block-closed = &apos;X&apos;.
      endif.
    endif.

    if r_block-interrupted is not initial.
      concatenate r_block-markup %_newline into r_block-markup.
      clear r_block-interrupted.
    endif.

    concatenate r_block-markup %_newline line-body into r_block-markup.
  endmethod.                    &quot;block_Markup_Continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="19 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_quote.
    data: lv_m1 type string.

    find regex &apos;^&gt;[ ]?(.*)&apos; in line-text submatches lv_m1.
    if sy-subrc = 0.
      shift lv_m1 left deleting leading space.
      r_block-element-name = &apos;blockquote&apos;.
      r_block-element-handler = &apos;lines&apos;.
      append lv_m1 to r_block-element-lines.
    endif.
  endmethod.                    &quot;block_Quote</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="20 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_QUOTE_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_quote_continue.
    data: lv_m1 type string.

    if line-text(1) = &apos;&gt;&apos;.
      r_block = block.
      find regex &apos;^&gt;[ ]?(.*)&apos; in line-text submatches lv_m1.
      if sy-subrc = 0.
        shift lv_m1 left deleting leading space.
        if r_block-interrupted is not initial.
          append initial line to r_block-element-lines.
          clear r_block-interrupted.
        endif.

        append lv_m1 to r_block-element-lines.
        return.
      endif.
    endif.

    if block-interrupted is initial.
      r_block = block.
      append line-text to r_block-element-lines.
    endif.
  endmethod.                    &quot;block_Quote_Continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_REFERENCE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="25 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_REFERENCE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_REFERENCE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_REFERENCE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_reference.
    data: lv_m1 type string,
          lv_m2 type string,
          lv_m3 type string,
          lv_m4 type string,
          lv_id type string,
          lo_ref_map type ref to lcl_hashmap,
          lo_ref_item type ref to lcl_hashmap,
          lo_ref_val type ref to lcl_string.

    find regex &apos;^\[(.+)\]:[ ]*&lt;?(\S+)&gt;?([ ]+[&quot;&apos;&apos;(](.+)[&quot;&apos;&apos;)])?[ ]*$&apos;
      in line-text submatches lv_m1 lv_m2 lv_m3 lv_m4.
    if sy-subrc = 0.
      lv_id = lv_m1. translate lv_id to lower case.

      lo_ref_map ?= me-&gt;definition_data-&gt;get( &apos;Reference&apos; ).
      lo_ref_item ?= lo_ref_map-&gt;get( lv_id ).

      lo_ref_val ?= lo_ref_item-&gt;get( &apos;url&apos; ). lo_ref_val-&gt;data = lv_m2.
      if lv_m3 is not initial.
        lo_ref_val ?= lo_ref_item-&gt;get( &apos;title&apos; ). lo_ref_val-&gt;data = lv_m4.
      endif.

      r_block-hidden = &apos;X&apos;.
    endif.
  endmethod.                    &quot;block_Reference</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_RULE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="21 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_RULE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_RULE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_RULE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_rule.
    data: lv_regex type string.

    concatenate &apos;^([&apos; line-text(1) &apos;])([ ]*\1){2,}[ ]*$&apos; into lv_regex.
    find regex lv_regex in line-text.
    if sy-subrc = 0.
      r_block-element-name = &apos;hr&apos;.
    endif.
  endmethod.                    &quot;block_Rule</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_SETEXTHEADER" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="22 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_SETEXTHEADER" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_SETEXTHEADER" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_SETEXTHEADER" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_setextheader.
    check block is not initial and block-type is initial and
          block-interrupted is initial.

    if line-text co line-text(1).
      r_block = block.
      if line-text(1) = &apos;=&apos;.
        r_block-element-name = &apos;h1&apos;.
      else.
        r_block-element-name = &apos;h2&apos;.
      endif.
    endif.
  endmethod.                    &quot;block_SetextHeader</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="26 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_table.
    data: lv_divider type string,
          lt_divider_cells type table of string,
          lv_len type i.
    field-symbols: &lt;divider_cell&gt; like line of lt_divider_cells,
                   &lt;alignment&gt; like line of r_block-alignments.

    check not ( block is initial or
                block-type is not initial or
                block-interrupted is not initial ).

    find &apos;|&apos; in block-element-text-text.
    if sy-subrc = 0 and line-text co &apos; -:|&apos;.
      r_block = block.

      lv_divider = trim( line-text ).
      lv_divider = trim( str = lv_divider  mask = &apos;|&apos; ).

      split lv_divider at &apos;|&apos; into table lt_divider_cells.
      loop at lt_divider_cells assigning &lt;divider_cell&gt;.
        &lt;divider_cell&gt; = trim( &lt;divider_cell&gt; ).
        check &lt;divider_cell&gt; is not initial.
        append initial line to r_block-alignments assigning &lt;alignment&gt;.

        if &lt;divider_cell&gt;(1) = &apos;:&apos;.
          &lt;alignment&gt; = &apos;left&apos;.
        endif.

        lv_len = strlen( &lt;divider_cell&gt; ) - 1.
        if &lt;divider_cell&gt;+lv_len(1) = &apos;:&apos;.
          if &lt;alignment&gt; = &apos;left&apos;.
            &lt;alignment&gt; = &apos;center&apos;.
          else.
            &lt;alignment&gt; = &apos;right&apos;.
          endif.
        endif.
      endloop. &quot;lt_divider_cells

      &quot;# ~

      data: lv_header type string,
            lt_header_cells type table of string,
            lv_index type i,
            lt_header_elements type ty_t_element2.
      field-symbols: &lt;header_cell&gt; like line of lt_header_cells,
                     &lt;header_element&gt; like line of lt_header_elements,
                     &lt;attribute&gt; like line of &lt;header_element&gt;-attributes.

      lv_header = trim( r_block-element-text-text ).
      lv_header = trim( str = lv_header  mask = &apos;|&apos; ).

      split lv_header at &apos;|&apos; into table lt_header_cells.
      loop at lt_header_cells assigning &lt;header_cell&gt;.
        lv_index = sy-tabix.
        &lt;header_cell&gt; = trim( &lt;header_cell&gt; ).

        append initial line to lt_header_elements assigning &lt;header_element&gt;.
        &lt;header_element&gt;-name = &apos;th&apos;.
        &lt;header_element&gt;-text = &lt;header_cell&gt;.
        &lt;header_element&gt;-handler = &apos;line&apos;.

        read table r_block-alignments assigning &lt;alignment&gt; index lv_index.
        if sy-subrc = 0 and &lt;alignment&gt; is not initial.
          append initial line to &lt;header_element&gt;-attributes assigning &lt;attribute&gt;.
          &lt;attribute&gt;-name = &apos;style&apos;.
          concatenate &apos;text-align: &apos; &lt;alignment&gt; &apos;;&apos;
            into &lt;attribute&gt;-value respecting blanks.
        endif.
      endloop.

      &quot;# ~

      field-symbols: &lt;element_text1&gt; like line of r_block-element-texts,
                     &lt;element_text2&gt; like line of &lt;element_text1&gt;-texts.

      r_block-identified = &apos;X&apos;.
      r_block-element-name = &apos;table&apos;.
      r_block-element-handler = &apos;elements&apos;.

      append initial line to r_block-element-texts assigning &lt;element_text1&gt;.
      &lt;element_text1&gt;-name = &apos;thead&apos;.
      &lt;element_text1&gt;-handler = &apos;elements&apos;.
      append initial line to &lt;element_text1&gt;-texts assigning &lt;element_text2&gt;.
      &lt;element_text2&gt;-name = &apos;tr&apos;.
      &lt;element_text2&gt;-handler = &apos;elements&apos;.
      &lt;element_text2&gt;-texts = lt_header_elements.

      append initial line to r_block-element-texts assigning &lt;element_text1&gt;.
      &lt;element_text1&gt;-name = &apos;tbody&apos;.
      &lt;element_text1&gt;-handler = &apos;elements&apos;.
    endif. &quot;sy-subrc = 0 and line-text na &apos; -:|&apos;.
  endmethod.                    &quot;block_Table</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE_CONTINUE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="27 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE_CONTINUE" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE_CONTINUE" SCONAME="BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="BLOCK_TABLE_CONTINUE" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method block_table_continue.
    data: lv_row type string,
          lt_matches type match_result_tab,
          lv_index type i,
          lv_cell type string.
    field-symbols: &lt;match&gt; like line of lt_matches,
                   &lt;text1&gt; like line of r_block-element-texts,
                   &lt;text2&gt; like line of &lt;text1&gt;-texts,
                   &lt;text3&gt; like line of &lt;text2&gt;-texts,
                   &lt;alignment&gt; like line of r_block-alignments,
                   &lt;attribute&gt; like line of &lt;text3&gt;-attributes.

    check block-interrupted is initial.

    if line-text cs &apos;|&apos;.
      r_block = block.

      lv_row = trim( line-text ).
      lv_row = trim( str = lv_row mask = &apos;|&apos; ).

      read table r_block-element-texts assigning &lt;text1&gt; index 2.
      check sy-subrc = 0.

      append initial line to &lt;text1&gt;-texts assigning &lt;text2&gt;.
      &lt;text2&gt;-name = &apos;tr&apos;.
      &lt;text2&gt;-handler = &apos;elements&apos;.

      find all occurrences of regex &apos;(?:(\\[|])|[^|`]|`[^`]+`|`)+&apos;
        in lv_row results lt_matches.
      loop at lt_matches assigning &lt;match&gt;.
        lv_index = sy-tabix.
        lv_cell = lv_row+&lt;match&gt;-offset(&lt;match&gt;-length).
        lv_cell = trim( lv_cell ).

        append initial line to &lt;text2&gt;-texts assigning &lt;text3&gt;.
        &lt;text3&gt;-name = &apos;td&apos;.
        &lt;text3&gt;-handler = &apos;line&apos;.
        &lt;text3&gt;-text = lv_cell.

        read table r_block-alignments assigning &lt;alignment&gt; index lv_index.
        if sy-subrc = 0 and &lt;alignment&gt; is not initial.
          append initial line to &lt;text3&gt;-attributes assigning &lt;attribute&gt;.
          &lt;attribute&gt;-name = &apos;style&apos;.
          concatenate &apos;text-align: &apos; &lt;alignment&gt; &apos;;&apos;
            into &lt;attribute&gt;-value respecting blanks.
        endif.
      endloop. &quot;lt_matches
    endif. &quot;line-text cs &apos;|&apos;
  endmethod.                    &quot;block_Table_Continue</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="CHOP" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="CHOP" SCONAME="STR" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="CHOP" SCONAME="MASK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING" PARVALUE="&apos; \t\n\r&apos;" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="CHOP" SCONAME="R_STR" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method chop.
    data: lv_regex type string.

    r_str = str.
    replace all occurrences of regex &apos;([\.\?\*\+\|])&apos; in mask with &apos;\\$1&apos;.
    concatenate &apos;[&apos; mask &apos;]*\Z&apos; into lv_regex.
    replace all occurrences of regex lv_regex in r_str with &apos;&apos;.
  endmethod.                    &quot;trim</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="P" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method constructor.
    &quot;! Constuctor method
    &quot;! Initializes the instance constants

    &quot;#
    &quot;# Lines
    &quot;#
    create object block_types
      exporting
        value_type = &apos;lcl_string_array&apos;.
    data: lo_sa type ref to lcl_string_array.
    lo_sa ?= block_types-&gt;new( &apos;#&apos; ). lo_sa-&gt;append( &apos;Header&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;*&apos; ). lo_sa-&gt;append( &apos;Rule&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;+&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;-&apos; ). lo_sa-&gt;append( &apos;SetextHeader&apos; ).
    lo_sa-&gt;append( &apos;Table&apos; ). lo_sa-&gt;append( &apos;Rule&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;0&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;1&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;2&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;3&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;4&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;5&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;6&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;7&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;8&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;9&apos; ). lo_sa-&gt;append( &apos;List&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;:&apos; ). lo_sa-&gt;append( &apos;Table&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;&lt;&apos; ). lo_sa-&gt;append( &apos;Comment&apos; ). lo_sa-&gt;append( &apos;Markup&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;=&apos; ). lo_sa-&gt;append( &apos;SetextHeader&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;&gt;&apos; ). lo_sa-&gt;append( &apos;Quote&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;[&apos; ). lo_sa-&gt;append( &apos;Reference&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;_&apos; ). lo_sa-&gt;append( &apos;Rule&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;`&apos; ). lo_sa-&gt;append( &apos;FencedCode&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;|&apos; ). lo_sa-&gt;append( &apos;Table&apos; ).
    lo_sa ?= block_types-&gt;new( &apos;~&apos; ). lo_sa-&gt;append( &apos;FencedCode&apos; ).

    create object unmarked_block_types.
    unmarked_block_types-&gt;append( &apos;Code&apos; ).

    &quot;#
    &quot;# Inline Elements
    &quot;#
    create object inline_types
      exporting
        value_type = &apos;lcl_string_array&apos;.
    lo_sa ?= inline_types-&gt;new( &apos;&quot;&apos; ). lo_sa-&gt;append( &apos;SpecialCharacter&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;!&apos; ). lo_sa-&gt;append( &apos;Image&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;&amp;&apos; ). lo_sa-&gt;append( &apos;SpecialCharacter&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;*&apos; ). lo_sa-&gt;append( &apos;Emphasis&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;:&apos; ). lo_sa-&gt;append( &apos;Url&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;&lt;&apos; ). lo_sa-&gt;append( &apos;UrlTag&apos; ). lo_sa-&gt;append( &apos;EmailTag&apos; ).
    lo_sa-&gt;append( &apos;Markup&apos; ). lo_sa-&gt;append( &apos;SpecialCharacter&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;&gt;&apos; ). lo_sa-&gt;append( &apos;SpecialCharacter&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;[&apos; ). lo_sa-&gt;append( &apos;Link&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;_&apos; ). lo_sa-&gt;append( &apos;Emphasis&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;`&apos; ). lo_sa-&gt;append( &apos;Code&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;~&apos; ). lo_sa-&gt;append( &apos;Strikethrough&apos; ).
    lo_sa ?= inline_types-&gt;new( &apos;\&apos; ). lo_sa-&gt;append( &apos;EscapeSequence&apos; ).

    &quot;#
    &quot;# Read-Only
    &quot;#
    create object special_characters. lo_sa = special_characters.
    lo_sa-&gt;append( &apos;\&apos; ). lo_sa-&gt;append( &apos;`&apos; ). lo_sa-&gt;append( &apos;*&apos; ).
    lo_sa-&gt;append( &apos;_&apos; ). lo_sa-&gt;append( &apos;{&apos; ). lo_sa-&gt;append( &apos;}&apos; ).
    lo_sa-&gt;append( &apos;[&apos; ). lo_sa-&gt;append( &apos;]&apos; ). lo_sa-&gt;append( &apos;(&apos; ).
    lo_sa-&gt;append( &apos;)&apos; ). lo_sa-&gt;append( &apos;&gt;&apos; ). lo_sa-&gt;append( &apos;#&apos; ).
    lo_sa-&gt;append( &apos;+&apos; ). lo_sa-&gt;append( &apos;-&apos; ). lo_sa-&gt;append( &apos;.&apos; ).
    lo_sa-&gt;append( &apos;!&apos; ). lo_sa-&gt;append( &apos;|&apos; ).

    data: lo_string type ref to lcl_string.
    create object strong_regex.
    lo_string ?= strong_regex-&gt;new( &apos;*&apos; ).
    lo_string-&gt;data = &apos;(^[*][*]((?:\\[*]|[^*]|[*][^*]*[*])+)[*][*](?![*]))&apos;.
    lo_string ?= strong_regex-&gt;new( &apos;_&apos; ).
    lo_string-&gt;data = &apos;(^__((?:\\_|[^_]|_[^_]*_)+)__(?!_))&apos;.

    create object em_regex.
    lo_string ?= em_regex-&gt;new( &apos;*&apos; ).
    lo_string-&gt;data = &apos;(^[*]((?:\\[*]|[^*]|[*][*][^*]+[*][*])+)[*](?![*]))&apos;.
    lo_string ?= em_regex-&gt;new( &apos;_&apos; ).
    lo_string-&gt;data = &apos;(^_((?:\\_|[^_]|__[^_]*__)+)_(?!_)\b)&apos;.

    regex_html_attribute = &apos;[a-zA-Z_:][\w:.-]*(?:\s*=\s*(?:[^&quot;&apos;&apos;=&lt;&gt;`\s]+|&quot;[^&quot;]*&quot;|&apos;&apos;[^&apos;&apos;]*&apos;&apos;))?&apos;.

    create object void_elements. lo_sa = void_elements.
    lo_sa-&gt;append( &apos;area&apos; ). lo_sa-&gt;append( &apos;base&apos; ). lo_sa-&gt;append( &apos;br&apos; ).
    lo_sa-&gt;append( &apos;col&apos; ). lo_sa-&gt;append( &apos;command&apos; ). lo_sa-&gt;append( &apos;embed&apos; ).
    lo_sa-&gt;append( &apos;hr&apos; ). lo_sa-&gt;append( &apos;img&apos; ). lo_sa-&gt;append( &apos;input&apos; ).
    lo_sa-&gt;append( &apos;link&apos; ). lo_sa-&gt;append( &apos;meta&apos; ). lo_sa-&gt;append( &apos;param&apos; ).
    lo_sa-&gt;append( &apos;source&apos; ).

    create object text_level_elements. lo_sa = text_level_elements.
    lo_sa-&gt;append( &apos;a&apos; ).  lo_sa-&gt;append( &apos;b&apos; ).  lo_sa-&gt;append( &apos;i&apos; ).  lo_sa-&gt;append( &apos;q&apos; ).
    lo_sa-&gt;append( &apos;s&apos; ).  lo_sa-&gt;append( &apos;u&apos; ).
    lo_sa-&gt;append( &apos;br&apos; ).  lo_sa-&gt;append( &apos;em&apos; ).  lo_sa-&gt;append( &apos;rp&apos; ).  lo_sa-&gt;append( &apos;rt&apos; ).
    lo_sa-&gt;append( &apos;tt&apos; ).  lo_sa-&gt;append( &apos;xm&apos; ).
    lo_sa-&gt;append( &apos;bdo&apos; ).  lo_sa-&gt;append( &apos;big&apos; ).  lo_sa-&gt;append( &apos;del&apos; ).  lo_sa-&gt;append( &apos;ins&apos; ).
    lo_sa-&gt;append( &apos;sub&apos; ).  lo_sa-&gt;append( &apos;sup&apos; ).  lo_sa-&gt;append( &apos;var&apos; ).  lo_sa-&gt;append( &apos;wbr&apos; ).
    lo_sa-&gt;append( &apos;abbr&apos; ).  lo_sa-&gt;append( &apos;cite&apos; ).  lo_sa-&gt;append( &apos;code&apos; ).
    lo_sa-&gt;append( &apos;font&apos; ).  lo_sa-&gt;append( &apos;mark&apos; ).  lo_sa-&gt;append( &apos;nobr&apos; ).
    lo_sa-&gt;append( &apos;ruby&apos; ).  lo_sa-&gt;append( &apos;span&apos; ).  lo_sa-&gt;append( &apos;time&apos; ).
    lo_sa-&gt;append( &apos;blink&apos; ).  lo_sa-&gt;append( &apos;small&apos; ).
    lo_sa-&gt;append( &apos;nextid&apos; ).  lo_sa-&gt;append( &apos;spacer&apos; ).  lo_sa-&gt;append( &apos;strike&apos; ).
    lo_sa-&gt;append( &apos;strong&apos; ).
    lo_sa-&gt;append( &apos;acronym&apos; ).  lo_sa-&gt;append( &apos;listing&apos; ).  lo_sa-&gt;append( &apos;marquee&apos; ).
    lo_sa-&gt;append( &apos;basefont&apos; ).

    &quot;// Method names
    data: lo_objdescr type ref to cl_abap_objectdescr.
    field-symbols: &lt;method&gt; like line of lo_objdescr-&gt;methods.
    lo_objdescr ?= cl_abap_objectdescr=&gt;describe_by_object_ref( me ).
    loop at lo_objdescr-&gt;methods assigning &lt;method&gt;.
      append &lt;method&gt;-name to me-&gt;methods.
    endloop.
  endmethod.                    &quot;constructor</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="ELEMENT" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="42 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="ELEMENT" SCONAME="ELEMENT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="ELEMENT" SCONAME="MARKUP" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method element.
    data: ls_element type ty_element,
          lv_method_name type string,
          lv_content type string.

    field-symbols: &lt;text&gt; type any,
                   &lt;attribute&gt; type ty_element_attribute.

    magic_move( exporting from = element changing to = ls_element ).
    assign component &apos;TEXT&apos; of structure ls_element to &lt;text&gt;.

    concatenate &apos;&lt;&apos; ls_element-name into markup.

    if ls_element-attributes is not initial.
      loop at ls_element-attributes assigning &lt;attribute&gt;.
        concatenate markup space &lt;attribute&gt;-name &apos;=&quot;&apos; &lt;attribute&gt;-value &apos;&quot;&apos;
          into markup respecting blanks.
      endloop.
    endif.

    if &lt;text&gt; is not initial or ls_element-texts is not initial or ls_element-lines is not initial.
      concatenate markup &apos;&gt;&apos; into markup respecting blanks.

      if ls_element-handler is not initial.
        lv_method_name = ls_element-handler.
        translate lv_method_name to upper case.

        if ls_element-texts is not initial. &quot;// for array of elements
          call method (lv_method_name)
            exporting
              elements = ls_element-texts
            receiving
              markup   = lv_content.
        elseif ls_element-lines is not initial. &quot;// for array of lines
          call method (lv_method_name)
            exporting
              lines  = ls_element-lines
            receiving
              markup = lv_content.
        else. &quot;// for simple text
          call method (lv_method_name)
            exporting
              element = &lt;text&gt;
            receiving
              markup  = lv_content.
        endif.
      else.
        if ls_element-lines is not initial.
          concatenate lines of ls_element-lines into lv_content separated by %_newline.
        else.
          assign component &apos;TEXT&apos; of structure &lt;text&gt; to &lt;text&gt;.
          lv_content = &lt;text&gt;.
        endif.
      endif.
      concatenate markup lv_content &apos;&lt;/&apos; ls_element-name &apos;&gt;&apos;
        into markup respecting blanks.

    else.
      concatenate markup &apos; /&gt;&apos; into markup respecting blanks.
    endif.
  endmethod.                    &quot;element</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="ELEMENTS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="43 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="ELEMENTS" SCONAME="ELEMENTS" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="ELEMENTS" SCONAME="MARKUP" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method elements.
    data: lt_markup type table of string.

    field-symbols: &lt;element&gt; type any,
                   &lt;markup&gt; type string.

    loop at elements assigning &lt;element&gt;.
      append initial line to lt_markup assigning &lt;markup&gt;.
      &lt;markup&gt; = element( &lt;element&gt; ).
    endloop.

    concatenate lines of lt_markup into markup separated by %_newline.
    concatenate %_newline markup %_newline into markup.
  endmethod.                    &quot;elements</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="HTMLSPECIALCHARS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="HTMLSPECIALCHARS" SCONAME="INPUT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="HTMLSPECIALCHARS" SCONAME="NO_QUOTES" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="FLAG" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="HTMLSPECIALCHARS" SCONAME="OUTPUT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method htmlspecialchars.
    output = input.
    replace all occurrences of &apos;&amp;&apos; in output with &apos;&amp;amp;&apos;.
    replace all occurrences of &apos;&lt;&apos; in output with &apos;&amp;lt;&apos;.
    replace all occurrences of &apos;&gt;&apos; in output with &apos;&amp;gt;&apos;.

    if no_quotes is not initial.
      replace all occurrences of &apos;&quot;&apos; in output with &apos;&amp;quot;&apos;.
      replace all occurrences of &apos;&apos;&apos;&apos; in output with &apos;&amp;#039;&apos;.
    endif.
  endmethod.                    &quot;htmlspecialchars</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_CODE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="30 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_CODE" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_CODE" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_code.
    data: lv_marker type c,
          lv_marker_comb type string,
          lv_m0 type string,
          lv_m1 type string,
          lv_text type string.

    lv_marker = excerpt-text(1).

    &quot;// Deal with the different repetitions (from 5 markers to 1)
    lv_marker_comb = &apos;&amp;&amp;&amp;&amp;&amp;&apos;.
    replace all occurrences of &apos;&amp;&apos; in lv_marker_comb with lv_marker.
    while lv_marker_comb is not initial.
      match_marked_string(
        exporting marker = lv_marker_comb  subject = excerpt-text
        importing m0 = lv_m0  m1 = lv_m1
        exceptions not_found = 4
      ).
      if sy-subrc = 0.
        lv_text = lv_m1. condense lv_text.
        lv_text = htmlspecialchars( lv_text ).
        replace all occurrences of regex &apos;[ ]*\n&apos; in lv_text with &apos; &apos;.

        r_inline-extent = strlen( lv_m0 ).
        r_inline-element-name = &apos;code&apos;.
        r_inline-element-text-text = lv_text.
        exit.
      endif.
      shift lv_marker_comb left.
    endwhile.
  endmethod.                    &quot;inline_code</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_EMAILTAG" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="31 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_EMAILTAG" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_EMAILTAG" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_emailtag.
    data: lv_m0 type string,
          lv_m1 type string,
          lv_m2 type string,
          lv_url type string.
    field-symbols: &lt;attribute&gt; like line of r_inline-element-attributes.

    check excerpt-text cs &apos;&gt;&apos;.
    find regex &apos;(^&lt;((mailto:)?\S+@\S+)&gt;)&apos; in excerpt-text ignoring case
      submatches lv_m0 lv_m1 lv_m2.
    if sy-subrc = 0.
      lv_url = lv_m1.
      if lv_m2 is initial.
        concatenate &apos;mailto:&apos; lv_url into lv_url.
      endif.

      r_inline-extent = strlen( lv_m0 ).
      r_inline-element-name = &apos;a&apos;.
      r_inline-element-text-text = lv_m1.

      append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
      &lt;attribute&gt;-name = &apos;href&apos;.
      &lt;attribute&gt;-value = lv_url.
    endif.
  endmethod.                    &quot;inline_EmailTag</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_EMPHASIS" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="32 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_EMPHASIS" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_EMPHASIS" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_emphasis.
    data: lv_marker type c,
          lv_emphasis type string,
          lv_m0 type string,
          lv_m1 type string,
          lo_regex type ref to lcl_string,
          lv_regex_delim type string,
          lv_offset type i.

    check excerpt-text is not initial.

    lv_marker = excerpt-text(1).

    lo_regex ?= me-&gt;strong_regex-&gt;get( lv_marker ).
    if strlen( excerpt-text ) &gt; 1 and excerpt-text+1(1) = lv_marker and
       lo_regex-&gt;data is not initial.
      find regex lo_regex-&gt;data in excerpt-text submatches lv_m0 lv_m1.
      if sy-subrc = 0.
        lv_emphasis = &apos;strong&apos;.

        &quot;// get the (ungreedy) end marker
        lv_regex_delim = &apos;[^&amp;][&amp;]{2}(?![&amp;])&apos;.
        replace all occurrences of &apos;&amp;&apos; in lv_regex_delim with lv_marker.
        find regex lv_regex_delim in lv_m1 match offset lv_offset.
        if sy-subrc = 0.
          add 1 to lv_offset.
          lv_m1 = lv_m1(lv_offset).
          lv_offset = strlen( lv_m1 ) + 4.
          lv_m0 = lv_m0(lv_offset).
        endif.
      endif.
    endif.

    lo_regex ?= me-&gt;em_regex-&gt;get( lv_marker ).
    if lv_emphasis is initial and lo_regex-&gt;data is not initial.
      find regex lo_regex-&gt;data in excerpt-text submatches lv_m0 lv_m1.
      if sy-subrc = 0.
        lv_emphasis = &apos;em&apos;.
      endif.
    endif.

    check lv_emphasis is not initial.

    r_inline-extent = strlen( lv_m0 ).
    r_inline-element-name = lv_emphasis.
    r_inline-element-handler = &apos;line&apos;.
    r_inline-element-text-text = lv_m1.
  endmethod.                    &quot;inline_Emphasis</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_ESCAPESEQUENCE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="33 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_ESCAPESEQUENCE" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_ESCAPESEQUENCE" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_escapesequence.
    data: lv_ch type c.

    check strlen( excerpt-text ) &gt; 1.
    lv_ch = excerpt-text+1(1).
    sy-tabix = me-&gt;special_characters-&gt;find( lv_ch ).
    if sy-tabix &gt; 0.
      r_inline-markup = excerpt-text+1(1).
      r_inline-extent = 2.
    endif.
  endmethod.                    &quot;inline_EscapeSequence</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_IMAGE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="34 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_IMAGE" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_IMAGE" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_image.
    data: ls_link like r_inline.
    field-symbols: &lt;attribute&gt; like line of r_inline-element-attributes,
                   &lt;attribute_from&gt; like line of ls_link-element-attributes.

    check strlen( excerpt-text ) &gt; 1 and
          excerpt-text+1(1) = &apos;[&apos;.
    excerpt-text = excerpt-text+1.

    ls_link = inline_link( excerpt ).
    check ls_link is not initial.

    r_inline-extent = ls_link-extent + 1.
    r_inline-element-name = &apos;img&apos;.

    append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
    &lt;attribute&gt;-name = &apos;src&apos;.
    read table ls_link-element-attributes assigning &lt;attribute_from&gt;
      with key name = &apos;href&apos;.
    if sy-subrc = 0.
      &lt;attribute&gt;-value = &lt;attribute_from&gt;-value.
      delete ls_link-element-attributes where name = &apos;href&apos;.
    endif.

    append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
    &lt;attribute&gt;-name = &apos;alt&apos;.
    &lt;attribute&gt;-value = ls_link-element-text-text.

    append lines of ls_link-element-attributes to r_inline-element-attributes.
  endmethod.                    &quot;inline_Image</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_LINK" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="35 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_LINK" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_LINK" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_link.
    constants: lc_regex_template type string value &apos;\[((?:[^\]\[]|(?R))*)\]&apos;.
    data: lv_remainder type string,
          lv_regex type string,
          lv_len type i,
          lv_m0 type string,
          lv_m1 type string,
          lv_m2 type string,
          lv_definition type string,
          lo_ref_map type ref to lcl_hashmap,
          lo_def_map type ref to lcl_hashmap,
          lo_def_val type ref to lcl_string,
          lv_exists type flag.

    field-symbols: &lt;attribute&gt; like line of r_inline-element-attributes.

    r_inline-element-name = &apos;a&apos;.
    r_inline-element-handler = &apos;line&apos;.

    lv_remainder = excerpt-text.

    concatenate &apos;(&apos; lc_regex_template &apos;)&apos; into lv_regex.
    do 5 times. &quot;// regex recursion
      replace &apos;(?R)&apos; in lv_regex with lc_regex_template.
    enddo.
    replace &apos;(?R)&apos; in lv_regex with &apos;$&apos;.

    find regex lv_regex in lv_remainder submatches lv_m0 lv_m1.
    if sy-subrc = 0.
      r_inline-element-text-text = lv_m1.
      r_inline-extent = strlen( lv_m0 ).
      lv_remainder = lv_remainder+r_inline-extent.
    else.
      clear r_inline. return.
    endif.

    find regex &apos;(^[(]((?:[^ ()]|[(][^ )]+[)])+)(?:[ ]+(&quot;[^&quot;]*&quot;|&apos;&apos;[^&apos;&apos;]*&apos;&apos;))?[)])&apos;
      in lv_remainder submatches lv_m0 lv_m1 lv_m2.
    if sy-subrc = 0.
      append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
      &lt;attribute&gt;-name = &apos;href&apos;. &lt;attribute&gt;-value = lv_m1.
      if lv_m2 is not initial.
        append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
        &lt;attribute&gt;-name = &apos;title&apos;.
        lv_len = strlen( lv_m2 ) - 2.
        &lt;attribute&gt;-value = lv_m2+1(lv_len).
      endif.

      lv_len = strlen( lv_m0 ).
      add lv_len to r_inline-extent.

    else.
      find regex &apos;(^\s*\[([^\[]*)\])&apos; in lv_remainder submatches lv_m0 lv_m1.
      if sy-subrc = 0.
        if lv_m1 is not initial.
          lv_definition = lv_m1.
        else.
          lv_definition = r_inline-element-text-text.
        endif.
        lv_len = strlen( lv_m0 ).
        add lv_len to r_inline-extent.
      else.
        lv_definition = r_inline-element-text-text.
      endif.

      translate lv_definition to lower case.
      lo_ref_map ?= me-&gt;definition_data-&gt;get( &apos;Reference&apos; ).
      lv_exists = lo_ref_map-&gt;exists( lv_definition ).
      if lv_exists is initial.
        clear r_inline. return.
      endif.

      lo_def_map ?= lo_ref_map-&gt;get( lv_definition ).

      lo_def_val ?= lo_def_map-&gt;get( &apos;url&apos; ).
      append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
      &lt;attribute&gt;-name = &apos;href&apos;. &lt;attribute&gt;-value = lo_def_val-&gt;data.

      lv_exists = lo_def_map-&gt;exists( &apos;title&apos; ).
      if lv_exists is not initial.
        lo_def_val ?= lo_def_map-&gt;get( &apos;title&apos; ).
        append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
        &lt;attribute&gt;-name = &apos;title&apos;. &lt;attribute&gt;-value = lo_def_val-&gt;data.
      endif.
    endif.

    read table r_inline-element-attributes assigning &lt;attribute&gt;
      with key name = &apos;href&apos;.
    replace &apos;&amp;&apos; in &lt;attribute&gt;-value with &apos;&amp;amp;&apos;.
    replace &apos;&lt;&apos; in &lt;attribute&gt;-value with &apos;&amp;lt;&apos;.
  endmethod.                    &quot;inline_Link</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_MARKUP" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="36 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_MARKUP" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_MARKUP" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_markup.
    data: lv_regex type string,
          lv_m0 type string.

    check me-&gt;markup_escaped is initial and
          excerpt-text cs &apos;&gt;&apos; and
          strlen( excerpt-text ) &gt; 1.

    find regex &apos;(^&lt;\/\w*[ ]*&gt;)&apos; in excerpt-text submatches lv_m0.
    if sy-subrc &lt;&gt; 0.
      find regex &apos;(^&lt;!---?[^&gt;-](?:-?[^-])*--&gt;)&apos; in excerpt-text submatches lv_m0.
      if sy-subrc &lt;&gt; 0.
        concatenate &apos;(^&lt;\w*(?:[ ]*&apos; me-&gt;regex_html_attribute &apos;)*[ ]*\/?&gt;)&apos;
          into lv_regex.
        find regex lv_regex in excerpt-text submatches lv_m0.
      endif.
    endif.

    if lv_m0 is not initial.
      r_inline-markup = lv_m0.
      r_inline-extent = strlen( lv_m0 ).
    endif.
  endmethod.                    &quot;inline_Markup</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_SPECIALCHARACTER" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="37 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_SPECIALCHARACTER" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_SPECIALCHARACTER" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_specialcharacter.
    data: lv_special type string.

    check excerpt-text is not initial.

    if excerpt-text(1) = &apos;&amp;&apos;.
      find regex &apos;^&amp;#?\w+;&apos; in excerpt-text.
      if sy-subrc &lt;&gt; 0.
        r_inline-markup = &apos;&amp;amp;&apos;.
        r_inline-extent = 1.
        return.
      endif.
    endif.

    case excerpt-text(1).
      when &apos;&gt;&apos;. lv_special = &apos;gt&apos;.
      when &apos;&lt;&apos;. lv_special = &apos;lt&apos;.
      when &apos;&quot;&apos;. lv_special = &apos;quot&apos;.
    endcase.
    if lv_special is not initial.
      concatenate &apos;&amp;&apos; lv_special &apos;;&apos; into r_inline-markup.
      r_inline-extent = 1.
    endif.
  endmethod.                    &quot;inline_SpecialCharacter</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_STRIKETHROUGH" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="38 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_STRIKETHROUGH" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_STRIKETHROUGH" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_strikethrough.
    data: lv_m0 type string,
          lv_m1 type string.

    check strlen( excerpt-text ) &gt; 1 and
          excerpt-text+1(1) = &apos;~&apos;.

    find regex &apos;(^~~(?=\S)([^(?:~~)]+)(?=\S)~~)&apos; in excerpt-text
      submatches lv_m0 lv_m1.
    if sy-subrc = 0.
      r_inline-extent = strlen( lv_m0 ).
      r_inline-element-name = &apos;del&apos;.
      r_inline-element-text-text = lv_m1.
      r_inline-element-handler = &apos;line&apos;.
    endif.
  endmethod.                    &quot;inline_Strikethrough</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_URL" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="39 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_URL" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_URL" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_url.
    data: lv_m0 type string,
          lv_offset type i.
    field-symbols: &lt;attribute&gt; like line of r_inline-element-attributes.

    check me-&gt;urls_linked is not initial and
          strlen( excerpt-text ) &gt; 2 and
          excerpt-text+2(1) = &apos;/&apos;.

    find regex &apos;(\bhttps?:[\/]{2}[^\s&lt;]+\b\/*)&apos; in excerpt-context
      ignoring case submatches lv_m0 match offset lv_offset.
    if sy-subrc = 0.
      r_inline-extent = strlen( lv_m0 ).
      r_inline-position = lv_offset + 1. &quot;// set to +1 so 0 is not initial
      r_inline-element-name = &apos;a&apos;.
      r_inline-element-text-text = lv_m0.

      append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
      &lt;attribute&gt;-name = &apos;href&apos;.
      &lt;attribute&gt;-value = lv_m0.
    endif.
  endmethod.                    &quot;inline_Url</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="INLINE_URLTAG" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="40 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_URLTAG" SCONAME="EXCERPT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_EXCERPT"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="INLINE_URLTAG" SCONAME="R_INLINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_INLINE"/>
   <source>method inline_urltag.
    data: lv_m0 type string,
          lv_m1 type string,
          lv_url type string.
    field-symbols: &lt;attribute&gt; like line of r_inline-element-attributes.

    check excerpt-text cs &apos;&gt;&apos;.

    find regex &apos;(^&lt;(\w+:\/{2}[^ &gt;]+)&gt;)&apos; in excerpt-text submatches lv_m0 lv_m1.
    if sy-subrc = 0.
      lv_url = lv_m1.
      replace all occurrences of &apos;&amp;&apos; in lv_url with &apos;&amp;amp;&apos;.
      replace all occurrences of &apos;&lt;&apos; in lv_url with &apos;&amp;lt;&apos;.

      r_inline-extent = strlen( lv_m0 ).
      r_inline-element-name = &apos;a&apos;.
      r_inline-element-text-text = lv_url.

      append initial line to r_inline-element-attributes assigning &lt;attribute&gt;.
      &lt;attribute&gt;-name = &apos;href&apos;.
      &lt;attribute&gt;-value = lv_url.
    endif.
  endmethod.                    &quot;inline_UrlTag</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="LI" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="44 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="LI" SCONAME="LINES" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="LI" SCONAME="MARKUP" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method li.
    data: lv_trimmed_markup type string.

    markup = lines( lines ).
    lv_trimmed_markup = trim( markup ).

    read table lines transporting no fields with key table_line = &apos;&apos;.
    if sy-subrc &lt;&gt; 0 and strlen( lv_trimmed_markup ) &gt;= 3 and lv_trimmed_markup(3) = &apos;&lt;p&gt;&apos;.
      markup = lv_trimmed_markup+3.
      find &apos;&lt;/p&gt;&apos; in markup match offset sy-fdpos.
      data: lv_pos_to type i.
      lv_pos_to = sy-fdpos + 4.
      concatenate markup(sy-fdpos) markup+lv_pos_to into markup.
    endif.
  endmethod.                    &quot;li</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="LINE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="29 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="LINE" SCONAME="ELEMENT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_ELEMENT4"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="LINE" SCONAME="MARKUP" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method line.
    data: lv_text type string,
          lv_unmarked_text type string,
          lv_marker_position type i,
          ls_excerpt type ty_excerpt,
          ls_inline type ty_inline,
          lv_marker type c,
          lo_inline_types_sa type ref to lcl_string_array,
          lv_method_name type string,
          lv_markup_part type string,
          lv_continue_loop type flag.

    field-symbols: &lt;inline_type&gt; like line of lo_inline_types_sa-&gt;data.

    &quot;# lv_text contains the unexamined text
    &quot;# ls_excerpt-text is based on the first occurrence of a marker
    lv_text = element-text.

    while lv_text is not initial.
      if not lv_text ca me-&gt;inline_marker_list.
        exit.
      endif.
      ls_excerpt-text = lv_text+sy-fdpos.
      lv_marker = ls_excerpt-text(1).

      find lv_marker in lv_text match offset lv_marker_position.

      ls_excerpt-context = lv_text.

      lo_inline_types_sa ?= me-&gt;inline_types-&gt;get( lv_marker ).
      clear lv_continue_loop.
      loop at lo_inline_types_sa-&gt;data assigning &lt;inline_type&gt;.
        concatenate &apos;inline_&apos; &lt;inline_type&gt; into lv_method_name.
        translate lv_method_name to upper case.
        call method (lv_method_name)
          exporting
            excerpt  = ls_excerpt
          receiving
            r_inline = ls_inline.

        &quot;# makes sure that the inline belongs to &quot;our&quot; marker
        check ls_inline is not initial.
        check not ls_inline-position &gt; lv_marker_position.

        &quot;# sets a default inline position
        if ls_inline-position is initial.
          ls_inline-position = lv_marker_position.
        else.
          subtract 1 from ls_inline-position.
        endif.

        &quot;# the text that comes before the inline
        if ls_inline-position &lt;= strlen( lv_text ).
          lv_unmarked_text = lv_text(ls_inline-position).
        else.
          lv_unmarked_text = lv_text.
        endif.

        &quot;# compile the unmarked text
        lv_markup_part = unmarked_text( lv_unmarked_text ).
        concatenate markup lv_markup_part into markup.

        &quot;# compile the inline
        if ls_inline-markup is not initial.
          concatenate markup ls_inline-markup into markup.
        else.
          lv_markup_part = element( ls_inline-element ).
          concatenate markup lv_markup_part into markup.
        endif.

        &quot;# remove the examined text
        data: lv_pos type i.
        lv_pos = ls_inline-position + ls_inline-extent.
        if lv_pos &lt;= strlen( lv_text ).
          lv_text = lv_text+lv_pos.
        else.
          clear lv_text.
        endif.

        lv_continue_loop = &apos;X&apos;. exit.
      endloop. &quot;me-&gt;inline_types-&gt;data
      check lv_continue_loop is initial.

      &quot;# the marker does not belong to an inline
      add 1 to lv_marker_position.
      if lv_marker_position &lt;= strlen( lv_text ).
        lv_unmarked_text = lv_text(lv_marker_position).
      else.
        lv_unmarked_text = lv_text.
      endif.
      lv_markup_part = unmarked_text( lv_unmarked_text ).
      concatenate markup lv_markup_part into markup.
      if lv_marker_position &lt;= strlen( lv_text ).
        lv_text = lv_text+lv_marker_position.
      else.
        clear lv_text.
      endif.
    endwhile.

    lv_markup_part = unmarked_text( lv_text ).
    concatenate markup lv_markup_part into markup.
  endmethod.                    &quot;line</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="LINES" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="LINES" SCONAME="LINES" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="LINES" SCONAME="MARKUP" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method lines.
    data: ls_current_block type ty_block,
          lv_line type string,
          lv_chopped_line type string,
          lt_parts type table of string,
          lv_shortage type i,
          lv_spaces type string,
          lv_indent type i,
          lv_text type string,
          lv_continue_to_next_line type flag.

    field-symbols: &lt;part&gt; like line of lt_parts.

    loop at lines into lv_line.

      lv_chopped_line = lv_line.
      replace regex &apos;\s+$&apos; in lv_chopped_line with &apos;&apos;.
      if strlen( lv_chopped_line ) = 0.
        ls_current_block-interrupted = &apos;X&apos;.
        continue.
      endif.

      if lv_line cs %_horizontal_tab.
        split lv_line at %_horizontal_tab into table lt_parts.
        loop at lt_parts assigning &lt;part&gt;.
          at first.
            lv_line = &lt;part&gt;.
            continue.
          endat.
          lv_shortage = 4 - ( strlen( lv_line ) mod 4 ).
          clear lv_spaces.
          do lv_shortage times.
            concatenate lv_spaces space into lv_spaces respecting blanks.
          enddo.
          concatenate lv_line lv_spaces &lt;part&gt; into lv_line respecting blanks.
        endloop. &quot;lt_parts
      endif.

      clear lv_spaces.
      find regex &apos;^(\s+)&apos; in lv_line submatches lv_spaces.
      lv_indent = strlen( lv_spaces ).
      if lv_indent &gt; 0.
        lv_text = lv_line+lv_indent.
      else.
        lv_text = lv_line.
      endif.

      &quot;# ~

      data: ls_line type ty_line.
      clear ls_line.
      ls_line-body = lv_line.
      ls_line-indent = lv_indent.
      ls_line-text = lv_text.

      &quot;# ~

      data: lv_method_name type string,
            ls_block type ty_block.
      if ls_current_block-continuable is not initial.
        clear ls_block.
        concatenate &apos;block_&apos; ls_current_block-type &apos;_continue&apos; into lv_method_name.
        translate lv_method_name to upper case.
        call method (lv_method_name)
          exporting
            line    = ls_line
            block   = ls_current_block
          receiving
            r_block = ls_block.
        if ls_block is not initial.
          ls_current_block = ls_block.
          continue.
        else.
          concatenate &apos;block_&apos; ls_current_block-type &apos;_complete&apos; into lv_method_name.
          translate lv_method_name to upper case.
          read table me-&gt;methods transporting no fields with key table_line = lv_method_name.
          if sy-subrc = 0.
            call method (lv_method_name)
              exporting
                block   = ls_current_block
              receiving
                r_block = ls_current_block.
          endif.
        endif. &quot;ls_block is not initial.
        clear ls_current_block-continuable.
      endif. &quot;ls_current_block-continuable is not initial.

      &quot;# ~

      data: lv_marker type string,
            lo_block_types type ref to lcl_string_array,
            lo_sa type ref to lcl_string_array.

      field-symbols: &lt;block_type&gt; type lcl_hashmap=&gt;ty_item.

      lv_marker = lv_text(1).

      &quot;# ~

      create object lo_block_types.
      lo_block_types-&gt;copy( me-&gt;unmarked_block_types ).

      read table me-&gt;block_types-&gt;data assigning &lt;block_type&gt;
        with key key = lv_marker.
      if sy-subrc = 0.
        lo_sa ?= &lt;block_type&gt;-value.
        lo_block_types-&gt;append_array( lo_sa ).
      endif.

      &quot;#
      &quot;# ~

      data: lt_blocks type table of ty_block.

      field-symbols: &lt;block_type_name&gt; type string.

      loop at lo_block_types-&gt;data assigning &lt;block_type_name&gt;.
        clear ls_block.
        concatenate &apos;block_&apos; &lt;block_type_name&gt; into lv_method_name.
        translate lv_method_name to upper case.
        call method (lv_method_name)
          exporting
            line    = ls_line
            block   = ls_current_block
          receiving
            r_block = ls_block.

        if ls_block is not initial.
          ls_block-type = &lt;block_type_name&gt;.

          if ls_block-identified is initial.
            append ls_current_block to lt_blocks.
            ls_block-identified = &apos;X&apos;.
          endif.

          concatenate &apos;block_&apos; &lt;block_type_name&gt; &apos;_continue&apos; into lv_method_name.
          translate lv_method_name to upper case.
          read table me-&gt;methods transporting no fields with key table_line = lv_method_name.
          if sy-subrc = 0.
            ls_block-continuable = &apos;X&apos;.
          endif.

          ls_current_block = ls_block.
          lv_continue_to_next_line = &apos;X&apos;.
          exit.
        endif.
      endloop. &quot;lo_block_types-&gt;data

      if lv_continue_to_next_line is not initial.
        clear lv_continue_to_next_line.
        continue.
      endif.

      &quot;# ~

      if ls_current_block is not initial and
         ls_current_block-type is initial and
         ls_current_block-interrupted is initial.
        concatenate ls_current_block-element-text-text %_newline lv_text
         into ls_current_block-element-text-text.
      else.
        append ls_current_block to lt_blocks.

        ls_current_block = me-&gt;paragraph( ls_line ).

        ls_current_block-identified = &apos;X&apos;.
      endif.

    endloop. &quot;lines

    &quot;# ~

    if ls_current_block-continuable is not initial.
      concatenate &apos;block_&apos; ls_current_block-type &apos;_complete&apos; into lv_method_name.
      translate lv_method_name to upper case.
      read table me-&gt;methods transporting no fields with key table_line = lv_method_name.
      if sy-subrc = 0.
        call method (lv_method_name)
          exporting
            block   = ls_current_block
          receiving
            r_block = ls_current_block.
      endif.
    endif.

    append ls_current_block to lt_blocks.
    delete lt_blocks index 1.

    &quot;# ~

    data: lv_block_markup type string.

    field-symbols: &lt;block&gt; like line of lt_blocks.

    loop at lt_blocks assigning &lt;block&gt;.
      check &lt;block&gt;-hidden is initial.

      if &lt;block&gt;-markup is not initial.
        lv_block_markup = &lt;block&gt;-markup.
      else.
        lv_block_markup = element( &lt;block&gt;-element ).
      endif.
      concatenate markup %_newline lv_block_markup into markup respecting blanks.
    endloop.

    concatenate markup %_newline into markup respecting blanks.
  endmethod.                    &quot;lines</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="MAGIC_MOVE" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MAGIC_MOVE" SCONAME="FROM" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MAGIC_MOVE" SCONAME="NAME" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MAGIC_MOVE" SCONAME="TO" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <source>method magic_move.
    &quot;!
    &quot;! Magic move-corresponding
    &quot;! Recursively handles any kind of structures
    &quot;!
    data: lo_td_from type ref to cl_abap_typedescr,
          lo_td_to type ref to cl_abap_typedescr,
          lo_sd_from type ref to cl_abap_structdescr,
          lo_sd_to type ref to cl_abap_structdescr.
    field-symbols: &lt;tab_from&gt; type table,
                   &lt;tab_to&gt; type table,
                   &lt;any_from&gt; type any,
                   &lt;any_to&gt; type any.
    field-symbols: &lt;comp_from&gt; like line of lo_sd_from-&gt;components,
                   &lt;comp_to&gt;   like line of lo_sd_to-&gt;components.

    lo_td_from = cl_abap_typedescr=&gt;describe_by_data( from ).
    lo_td_to   = cl_abap_typedescr=&gt;describe_by_data( to ).
    if lo_td_from-&gt;absolute_name = lo_td_to-&gt;absolute_name.
      to = from.
      return.
    endif.

    &quot;// Scenario 1 =&gt; simple to simple
    if lo_td_from-&gt;kind = lo_td_to-&gt;kind and
       lo_td_from-&gt;kind = cl_abap_typedescr=&gt;kind_elem.
      move from to to.

      &quot;// Scenario 2 =&gt; struct to struct
    elseif lo_td_from-&gt;kind = lo_td_to-&gt;kind and
           lo_td_from-&gt;kind = cl_abap_typedescr=&gt;kind_struct.
      lo_sd_from ?= lo_td_from.
      lo_sd_to ?= lo_td_to.
      loop at lo_sd_from-&gt;components assigning &lt;comp_from&gt;.
        read table lo_sd_to-&gt;components assigning &lt;comp_to&gt;
          with key name = &lt;comp_from&gt;-name.
        check sy-subrc = 0.
        if &lt;comp_to&gt;-type_kind = cl_abap_typedescr=&gt;typekind_table.
          assign component &lt;comp_to&gt;-name of structure from to &lt;tab_from&gt;.
          assign component &lt;comp_to&gt;-name of structure to to &lt;tab_to&gt;.
          loop at &lt;tab_from&gt; assigning &lt;any_from&gt;.
            append initial line to &lt;tab_to&gt; assigning &lt;any_to&gt;.
            magic_move(
              exporting from = &lt;any_from&gt; name = &lt;comp_to&gt;-name
              changing to = &lt;any_to&gt;
            ).
          endloop.
        else.
          assign component &lt;comp_to&gt;-name of structure from to &lt;any_from&gt;.
          assign component &lt;comp_to&gt;-name of structure to to &lt;any_to&gt;.
          magic_move(
            exporting from = &lt;any_from&gt; name = &lt;comp_to&gt;-name
            changing to = &lt;any_to&gt;
          ).
        endif.
      endloop.

      &quot;// Scenario 3 =&gt; simple to struct
    elseif lo_td_from-&gt;kind = cl_abap_typedescr=&gt;kind_elem and
           lo_td_to-&gt;kind = cl_abap_typedescr=&gt;kind_struct and
           name is not initial.
      lo_sd_to ?= lo_td_to.
      read table lo_sd_to-&gt;components assigning &lt;comp_to&gt;
        with key name = name.
      if sy-subrc = 0 and
         &lt;comp_to&gt;-type_kind &lt;&gt; cl_abap_typedescr=&gt;typekind_table.
        assign component &lt;comp_to&gt;-name of structure to to &lt;any_to&gt;.
        magic_move(
          exporting from = from name = &lt;comp_to&gt;-name
          changing to = &lt;any_to&gt;
        ).
      endif.

      &quot;// Scenario 4 =&gt; struct to simple
    elseif lo_td_from-&gt;kind = cl_abap_typedescr=&gt;kind_struct and
           lo_td_to-&gt;kind = cl_abap_typedescr=&gt;kind_elem and
           name is not initial.
      lo_sd_from ?= lo_td_from.
      read table lo_sd_from-&gt;components assigning &lt;comp_from&gt;
        with key name = name.
      if sy-subrc = 0 and
         &lt;comp_from&gt;-type_kind &lt;&gt; cl_abap_typedescr=&gt;typekind_table.
        assign component &lt;comp_from&gt;-name of structure to to &lt;any_from&gt;.
        magic_move(
          exporting from = &lt;any_from&gt; name = &lt;comp_from&gt;-name
          changing to = to
        ).
      endif.
    endif.
  endmethod.                    &quot;magic_move</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="MATCH_MARKED_STRING" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MATCH_MARKED_STRING" SCONAME="MARKER" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MATCH_MARKED_STRING" SCONAME="SUBJECT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MATCH_MARKED_STRING" SCONAME="M0" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="MATCH_MARKED_STRING" SCONAME="M1" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <exception CLSNAME="ZMARKDOWN" CMPNAME="MATCH_MARKED_STRING" SCONAME="NOT_FOUND" VERSION="1" LANGU="P" MTDTYPE="0" EDITORDER="1 "/>
   <source>method match_marked_string.
    &quot;!
    &quot;! Workaround for an ungreedy regex match
    &quot;! Specific for regex matches with a delimiting marker
    &quot;!
    constants: lc_regex type string value &apos;(^{&amp;X}[ ]*(.+)[ ]*{&amp;X}(?!{&amp;1}))&apos;,
               lc_regex_delim type string value &apos;[^{&amp;1}]{&amp;X}(?!{&amp;1})&apos;.
    data: lv_marker_ptn type string,
          lv_submarker_ptn type string,
          lv_regex type string,
          lv_regex_delim type string,
          lv_offset type i.

    lv_marker_ptn = marker.
    replace all occurrences of regex &apos;([*?!+])&apos; in lv_marker_ptn with &apos;[$1]&apos;.
    lv_submarker_ptn = marker(1).
    replace all occurrences of regex &apos;([*?!+])&apos; in lv_submarker_ptn with &apos;[$1]&apos;.

    lv_regex = lc_regex.
    replace all occurrences of &apos;{&amp;1}&apos; in lv_regex with lv_submarker_ptn.
    replace all occurrences of &apos;{&amp;X}&apos; in lv_regex with lv_marker_ptn.

    lv_regex_delim = lc_regex_delim.
    replace all occurrences of &apos;{&amp;1}&apos; in lv_regex_delim with lv_submarker_ptn.
    replace all occurrences of &apos;{&amp;X}&apos; in lv_regex_delim with lv_marker_ptn.

    find regex lv_regex in subject submatches m0 m1.
    if sy-subrc = 0.
      find regex lv_regex_delim in m1 match offset lv_offset.
      if sy-subrc = 0.
        add 1 to lv_offset.
        m1 = m1(lv_offset).
        lv_offset = strlen( m1 ) + ( strlen( marker ) * 2 ).
        m0 = m0(lv_offset).
      endif.
    else.
      raise not_found.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="PARAGRAPH" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="28 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="PARAGRAPH" SCONAME="LINE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_LINE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="PARAGRAPH" SCONAME="R_BLOCK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TY_BLOCK"/>
   <source>method paragraph.
    r_block-element-name = &apos;p&apos;.
    r_block-element-text-text = line-text.
    r_block-element-handler = &apos;line&apos;.
  endmethod.                    &quot;paragraph</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="SET_BREAKS_ENABLED" VERSION="1" LANGU="P" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="SET_BREAKS_ENABLED" SCONAME="BREAKS_ENABLED" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="SET_BREAKS_ENABLED" SCONAME="THIS" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZMARKDOWN"/>
   <source>method set_breaks_enabled.
    me-&gt;breaks_enabled = breaks_enabled.
    this = me.
  endmethod.                    &quot;set_breaks_enabled</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="SET_MARKUP_ESCAPED" VERSION="1" LANGU="P" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="SET_MARKUP_ESCAPED" SCONAME="MARKUP_ESCAPED" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="SET_MARKUP_ESCAPED" SCONAME="THIS" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZMARKDOWN"/>
   <source>method set_markup_escaped.
    me-&gt;markup_escaped = markup_escaped.
    this = me.
  endmethod.                    &quot;set_markup_escaped</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="SET_URLS_LINKED" VERSION="1" LANGU="P" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="SET_URLS_LINKED" SCONAME="URLS_LINKED" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="SET_URLS_LINKED" SCONAME="THIS" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZMARKDOWN"/>
   <source>method set_urls_linked.
    me-&gt;urls_linked = urls_linked.
    this = me.
  endmethod.                    &quot;set_urls_linked</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="TEXT" VERSION="1" LANGU="P" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="TEXT" SCONAME="TEXT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="TEXT" SCONAME="MARKUP" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method text.
    &quot;! Parses the markdown text and returns the markup

    data: lt_lines type table of string.

    &quot;# make sure no definitions are set
    create object me-&gt;definition_data
      exporting
        value_type = &apos;lcl_hashmap:lcl_hashmap&apos;.

    &quot;# standardize line breaks
    replace all occurrences of regex &apos;\r?\n&apos; in text with %_newline.

    &quot;# remove surrounding line breaks
    text = trim( str = text mask = &apos;\n&apos; ).

    &quot;# split text into lines
    split text at %_newline into table lt_lines.

    &quot;# iterate through lines to identify blocks
    markup = me-&gt;lines( lt_lines ).

    &quot;# trim line breaks
    markup = trim( str = markup mask = &apos;\n&apos; ).
  endmethod.                    &quot;text</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="TRIM" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="TRIM" SCONAME="STR" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="TRIM" SCONAME="MASK" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING" PARVALUE="&apos; \t\n\r&apos;" PAROPTIONL="X"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="TRIM" SCONAME="R_STR" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method trim.
    data: lv_regex type string.

    r_str = str.
    replace all occurrences of regex &apos;([\.\?\*\+\|])&apos; in mask with &apos;\\$1&apos;.
    concatenate &apos;(\A[&apos; mask &apos;]*)|([&apos; mask &apos;]*\Z)&apos; into lv_regex.
    replace all occurrences of regex lv_regex in r_str with &apos;&apos;.
  endmethod.                    &quot;trim</source>
  </method>
  <method CLSNAME="ZMARKDOWN" CMPNAME="UNMARKED_TEXT" VERSION="1" LANGU="P" EXPOSURE="0" STATE="1" EDITORDER="41 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="UNMARKED_TEXT" SCONAME="TEXT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZMARKDOWN" CMPNAME="UNMARKED_TEXT" SCONAME="R_TEXT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method unmarked_text.
    data: lv_break type string.

    concatenate &apos;&lt;br /&gt;&apos; %_newline into lv_break.
    r_text = text.

    if me-&gt;breaks_enabled is not initial.
      replace all occurrences of regex &apos;[ ]*\n&apos; in r_text with lv_break.
    else.
      replace all occurrences of regex &apos;(?:[ ][ ]+|[ ]*\\)\n&apos; in r_text with lv_break.
      replace all occurrences of regex &apos; \n&apos; in r_text with %_newline.
    endif.
  endmethod.                    &quot;unmarked_text</source>
  </method>
 </CLAS>
</nugget>
